#!/usr/bin/env perl
# 
#     WebCheck - check web services and notify when they are down
# 
# 
# Author: Michael McClennen <mmcclenn@geology.wisc.edu>
# 
# This script is designed to be run periodically as a cron job. Depending on the
# configuration, it can check for an acceptable response from one or more web
# services, and can also check free disk space. Output is written to STDOUT by
# default, which in the context of cron allows for it to be directed to the
# responsible personnel through an email inbox or a text message gateway using
# the MAILTO variable. Output can also be sent directly through sendmail. It is
# recommended that this script be run every 10 minutes, or as often as necessary
# to ensure prompt notification of outages.
# 
# The results of all status checks are written to a log file, and the status of
# each service is also stored in a state file. This persistent state enables an
# abnormal condition to be notified once when it occurs, with a specified
# follow-up notification pattern.
# 
# Originally written in the 1990s.
# Rewritten: 2019-02-25, 2023-12-02


use strict;

use feature 'say';
no warnings 'uninitialized';

use Pod::Usage;
use YAML::Tiny;

our ($VERSION) = '1.0';


# Files and directories, with defaults

my $CONFIG_FILE = 'webcheck.yml';
my $DEFAULT_LOG = 'webcheck.log';
my $LOG_DIR = '.';
my $STATE_DIR;


# Operation modes

my $CHECK;
my $NOTIFY;
my $REPORT = '';
my $SENDMAIL;
my $TEST;


# Other global declarations

my ($log_file, $log_fh, $state_file, $state_fh);

my %state_uniq;

sub OutputMessage;
sub LogMessage;
sub AddSubject;
sub WriteLog;
sub WriteState;

my %TOPLEVEL = (checks => 1, log_dir => 1, log_file => 1, state_dir => 1,
		recipients => 1, recipients_report => 1, from => 1, envelope_from => 1,
		url_command => 1, url_followup => 1, 
		df_command => 1, df_limit => 1,	sysinfo_command => 1);


# All of the log entries and state entries generated by this run will have a single
# timestamp.

my $curtime = time;
my $timestamp = scalar(localtime);


# Parse the command-line options, if any. See the help message below for a
# description of the options.

my $flags = '';

while ( @ARGV )
{
    if ( $ARGV[0] =~ / ^ - ([cnrst]+) $ /x )
    {
	$flags .= $1;
	shift @ARGV;
    }
    
    if ( $ARGV[0] =~ / ^ - ([cnrst]*) f $ | ^ --file $ /x )
    {
	$flags .= $1; 
	shift @ARGV;
	$CONFIG_FILE = shift @ARGV or die "ERROR: you must specify a configuration file name\n";
    }
    
    elsif ( $ARGV[0] =~ / ^ --file=(.*) /x )
    {
	$CONFIG_FILE = $1 or die "ERROR: you must specify a configuration file name\n";
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --check $ /x )
    {
	$flags .= 'c';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --notify $ /x )
    {
	$flags .= 'n';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --report $ /x )
    {
	$flags .= 'r';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --sendmail $ /x )
    {
	$flags .= 's';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --test $ /x )
    {
	$flags .= 't';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ /^-h$|^--help$/ )
    {
	pod2usage(-exitval => 0, -verbose => 0);
	exit;
    }
    
    elsif ( $ARGV[0] =~ /^-m$|^--man$/ )
    {
	pod2usage(-exitval => 0, -verbose => 2);
	exit;
    }
    
    elsif ( $ARGV[0] eq '-' )
    {
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ /^-/ )
    {
	die "ERROR: unrecognized option '$ARGV[0]'\n";
    }
    
    else
    {
	last;
    }
}

$CHECK = 1 if $flags =~ /c/;
$NOTIFY = 1 if $flags =~ /n/;
$REPORT = 'REPORT ' if $flags =~ /r/;
$SENDMAIL = 1 if $flags =~ /s/;
$TEST = 1 if $flags =~ /t/;

die "ERROR: you may not specify --check and --notify together\n" if $CHECK && $NOTIFY;
die "ERROR: you may not specify --check and --report together\n" if $CHECK && $REPORT;

# The default mode is check unless either notify or report were explicitly specified.

$CHECK = 1 unless $NOTIFY || $REPORT;


# Read and validate the configuration file.

my ($CONFIG, @INDENTED_ENTRIES);

&ReadConfigurationFile($CONFIG_FILE);


# Process the remaining arguments, which should specify entries in the
# configuration file to be checked. If no arguments were given, default to
# 'all'. Any output that is generated will be appended to @OUTPUT.

my (@OUTPUT, %SUBJECT_LABEL, @SUBJECT_CODE);

push @ARGV, 'all' unless @ARGV;

&PerformStatusChecks(@ARGV);


# If any output was generated, send it out now. Otherwise, exit silently unless
# we are running in test mode.

if ( @OUTPUT || $TEST )
{
    &SendOutput;
}

exit;


# ReadConfigurationFile ( filename )
# 
# Read and parse the specified file, which must be in YAML format. Store the
# configuration variables as a hashref in $CONFIG.

sub ReadConfigurationFile {
    
    my ($filename) = @_;
    
    # Read the specified file, or die if an error occurs.
    
    die "ERROR: could not read $CONFIG_FILE: $!\n" unless -r $CONFIG_FILE;
    
    $CONFIG = YAML::Tiny->read($CONFIG_FILE);
    
    $CONFIG = $CONFIG->[0];
    
    # Validate the file contents.
    
    foreach my $key ( keys $CONFIG->%* )
    {
	warn "WARNING: invalid key '$key' in $CONFIG_FILE\n"
	    unless $TOPLEVEL{$key};
	
	if ( $key eq 'log_dir' && $CONFIG->{$key} )
	{
	    $LOG_DIR = $CONFIG->{$key};
	}
	
	elsif ( $key eq 'state_dir' && $CONFIG->{$key} )
	{
	    $STATE_DIR = $CONFIG->{$key};
	}
	
	elsif ( $key eq 'log_file' && $CONFIG->{$key} )
	{
	    $DEFAULT_LOG = $CONFIG->{$key};
	}
    }
    
    die "ERROR: you must have 'checks' as a top-level key in $CONFIG_FILE\n" 
	unless ref $CONFIG eq 'HASH' && $CONFIG->{checks};

    # Now read the raw file contents, and grab the indented entry names in
    # order. It is important that the checks are always done in the same order
    # so that the notification output will be consistent. The YAML::Tiny module
    # cannot give us the order in which the checks are listed in the file, so we
    # use this hack instead.
    
    open(my $ifh, '<', $CONFIG_FILE) or 
	die "ERROR: could not read $CONFIG_FILE: $!\n";
    
    while ( my $line = <$ifh> )
    {
	if ( $line =~ qr{ ^ \s+ (\S+) : }xs )
	{
	    push @INDENTED_ENTRIES, $1 if ref $CONFIG->{checks}{$1} eq 'HASH';
	}
    }
}


# PerformStatusChecks ( entry... )
# 
# Carry out one or more status checks, using entries specified in the
# configuration file. See the help message for more details.

sub PerformStatusChecks {
    
    my %name_uniq;
    
    # Iterate through the list of arguments provided to this subroutine.
    
 ENTRY:
    while ( @_ )
    {
	my $check_name = shift @_;
	
	# Ignore empty entries, and perform each check only once.
	
	next ENTRY unless $check_name && ! $name_uniq{$check_name};
	
	$name_uniq{$check_name} = 1;
	
	# The keyword 'all' expands to all of the entries under 'checks' in the
	# order in which they appear in the configuration file.
	
	if ( $check_name eq 'all' )
	{
	    unshift @_, grep { $CONFIG->{checks}{$_} } @INDENTED_ENTRIES;
	    next ENTRY;
	}
	
	# Throw an exception if we are asked to perform a nonexistent check.
	
	unless ( exists $CONFIG->{checks}{$check_name} )
	{
	    die "ERROR: could not find '$check_name' in $CONFIG_FILE\n";
	}
	
	# If the check exists but is empty, skip it.
	
	my $specification = $CONFIG->{checks}{$check_name};
	
	next ENTRY unless $specification;
	
	# If the value of the entry is a string, it represents a list of other entries to be
	# checked. So split it on whitespace and replace it in the entry list with a list of the
	# resulting strings.
	
	if ( ! ref $specification )
	{
	    my @list = split /\s+/, $specification;
	    
	    foreach my $e ( reverse @list )
	    {
		unshift @_, $e if $e;
	    }
	    
	    next ENTRY;
	}
	
	# If the entry includes the key 'url' or 'url_command', it represents a server status
	# check.
	
	if ( $specification->{url} || $specification->{url_command} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckWebService($check_name, $specification);
	}
	
	# If the entry includes the key 'limit', it represents a disk space check.
	
	elsif ( $specification->{limit} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckDiskSpace($check_name, $specification);
	}
	
	# If the entry includes any of the keys 'load_limit', 'mem_limit', or
	# 'procs_limit', it represents a system status check.
	
	elsif ( $specification->{load_limit} || $specification->{mem_limit} ||
		$specification->{swap_imit} || $specification->{procs_limit} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckSystemStatus($check_name, $specification);
	}
	
	# If the entry includes the key 'cycle', it can be used to test this
	# system. 
	
	elsif ( defined $specification->{cycle} && $specification->{cycle} ne '' )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckTest($check_name, $specification);
	}
	
	# Otherwise, throw an exception.
	
	else
	{
	    die "ERROR: could not determine entry type for '$check_name' in $CONFIG_FILE\n";
	}
    }
    
    # If a log file has been opened, close it now.
    
    close $log_fh if $log_fh;
}


# CheckWebService ( name, parameters )
# 
# Check the status of a remote server, by fetching a specified URL.

sub CheckWebService {

    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $command = $params->{url_command} || $CONFIG->{url_command} || "curl --head --silent '%%'";
    my $followup = $params->{url_followup} || $CONFIG->{url_followup} || '';
    my $check_url = $params->{url};
    my $label = $params->{label} || $name;
    my $subject = $params->{subject} || $label;
    
    # If the command string contains '%', replace each instance with the value of
    # $check_url.
    
    if ( $command =~ /%%/ )
    {
	unless ( $check_url && $check_url =~ qr{ ^ \w+ :// [\w.:]+ / .* }xs )
	{
	    die "ERROR: $name: '$check_url' does not look like a URL, in $CONFIG_FILE\n";
	}
	
	$command =~ s/%%/$check_url/g;
    }
    
    # Use the indicated command to fetch the specified page. If we don't get a
    # valid HTTP response code, set the code to a string indicating an error.
    # The code EXC indicates that the command could not execute, while NOR could
    # mean anything from the command terminating prematurely to the remote
    # server being completely hung.
    
    my ($response, $code);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    elsif ( $response =~ qr{ ^ HTTP/\d[.]\d \s+ (\d+) }xsi )
    {
	$code = $1;
    }
    
    else
    {
	$code = 'NOR';
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the state file are as follows:
    # 
    # 1. The previous status of the service (OK or DOWN)
    # 2. The time at which that result was first observed
    # 3. The number of DOWN results in a row since the last OK
    # 4. The HTTP response code from the service, or NOR for no response
    # 5. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $pcount, $pcode) = split /[|]/, $prior;
    
    # If the response code is 200 and the prior status is 'OK', then everything
    # is hunky dory. Generate output only if running in report or check mode,
    # but generate a log entry in any mode except check. This should be the case
    # on the vast majority of runs of this script.
    
    if ( $code eq '200' && $pstatus eq 'OK' )
    {
	OutputMessage "OK $label" if $REPORT || $CHECK;
	AddSubject 'OK', $subject;
	WriteLog "OK $label";
	return;
    }
    
    # If the response code is 200 and the prior state is not 'OK', generate a
    # notification that the checked server is okay again.
    
    elsif ( $code eq '200' )
    {
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    LogMessage "OK $elapsed $label";
	}
	
	else
	{
	    LogMessage "OK $label";
	}
	
	AddSubject 'OK', $subject;
	WriteState "OK|$curtime|0|200|$label" if $NOTIFY;
	return;
    }
    
    # If the code is anything else, and the prior status was 'OK', generate an
    # initial notification that something is wrong.
    
    elsif ( ! $pcount > 0 )
    {
	LogMessage "DOWN $label ($code)";
	AddSubject 'DOWN', $subject;
	WriteState "DOWN|$curtime|1|$code|$label" if $NOTIFY;
	return;
    }
    
    # Otherwise, this is a continuing bad status situation. Determine if we
    # should send a followup notification based on the followup pattern for this
    # entry. Compute the elapsed time since the bad status was first noticed,
    # and generate a notification if appropriate.
    
    else
    {
	my $count = $pcount + 1;
	my @followup_times = split /[\s,]+/, $followup;
	my $is_followup;
	
	foreach my $n ( @followup_times )
	{
	    $is_followup = 1 if $n == $pcount;
	}
	
	my $elapsed = ComputeElapsed($curtime, $ptime);
	
	my $message = "DOWN $label $elapsed ($code)";
	
	# Generate output if the new response code is different from the
	# prior code, or if we are running in report mode, or if the count matches
	# one of the numbers specified by the entry parameter 'followup'.
	
	if ( $code ne $pcode || $REPORT || $CHECK || $is_followup )
	{
	    OutputMessage $message;
	    AddSubject 'DOWN', $subject;
	}
	
	WriteLog $message;
	WriteState "DOWN|$ptime|$count|$code|$label" if $NOTIFY;
	return;
    }
}


# CheckDiskSpace ( name, parameters )
# 
# Check if any of the local disks are getting full, or do that check on a remote
# server.

sub CheckDiskSpace {
    
    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry. The 'limit' parameter indicates the
    # disk %used threshold at which a warning will be generated. The optional 'lower'
    # parameter indicates how low the %used must fall before the state returns to 'OK'.
    # Both of these parameters can be overridden on a per-volume basis, e.g.
    # 'limit_/var: 95'.
    
    my $command = $params->{df_command} || $CONFIG->{df_command} || 'df';
    my $ignore_entries = $params->{ignore} || "_IGNORE NOTHING_";
    my $default_limit = $params->{limit};
    my $default_lower = $params->{lower};
    my $label = $params->{label} || $name;
    my $subject = $params->{subject} || $label;
    
    die "ERROR: $name: invalid value '$default_limit' for 'limit'\n"
	unless $default_limit > 0 && $default_limit <= 100;
    
    die "ERROR: $name: invalid value '$default_lower' for 'lower'\n"
	if $default_lower && ! ($default_lower > 0 && $default_lower <= 100);
    
    # Run the indicated command, which will typically be `df` or `ssh ... df`.
    
    my ($response, $code, %over_limit, @volumes, @details, @output);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    else
    {
	$code = 'OK';
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the state file are as follows:
    # 
    # 1. The previous status of the service (OK, WARN, or FULL)
    # 2. The timestamp at which that result was first observed
    # 3. A summary of all volumes whose status is WARN or FULL
    # 4. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $psummary) = split /[|]/, $prior;
    
    # Parse the output, looking for lines which indicate a disk that is full
    # past the specified limit.
    
    my @lines = split /\n/, $response;
    
    foreach my $line ( @lines )
    {
	next if $line =~ /$ignore_entries/;
	
	next unless $line =~ qr{ \s (\d+) [%] \s+ ( / \S* ) }xs;
	
	my $used = $1;
	my $volume = $2;
	
	my $limit = $default_limit;
	
	push @volumes, $volume;
	
	if ( my $by_volume = $params->{"limit_" . $volume} )
	{
	    die "ERROR: $name: invalid value '$by_volume' for 'limit_$volume'\n"
		unless $by_volume > 0 && $by_volume <= 100;
	    
	    $limit = $by_volume;
	}
	
	my $lower = $default_lower;
	
	if ( my $by_volume = $params->{"lower_" . $volume} )
	{
	    die "ERROR: $name: invalid value '$by_volume' for 'lower_$volume'\n"
		unless $by_volume > 0 && $by_volume <= 100;
	    
	    $lower = $by_volume;
	}
	
	if ( $used eq '100' )
	{
	    $code = 'FULL';
	    push @details, "$volume 100";
	    push @output, "*** $volume 100 ***";
	    $over_limit{$volume} = $used;
	}
	
	elsif ( $used >= $limit )
	{
	    $code = 'WARN' unless $code eq 'FULL';
	    push @details, "$volume $used";
	    push @output, "* $volume $used *";
	    $over_limit{$volume} = $used;
	}
	
	elsif ( $pstatus && $pstatus ne 'OK' && $lower && $used > $lower )
	{
	    $code = 'WARN' unless $code eq 'FULL';
	    push @details, "$volume $used";
	    push @output, "- $volume $used -";
	    $over_limit{$volume} = $used;
	}
	
	elsif ( $CHECK || $REPORT )
	{
	    push @output, "$volume $used";
	}
    }
    
    # Generate a summary which lists the use percentage of every volume that is at or
    # over its limit. This will be written to the log, and may be used to generate the
    # new state. If none of the volumes are at or over limit, @details will be empty.
    
    my $summary = join ' - ', @details;
    
    # Generate output and possibly update the state file if the status code has changed
    # from the prior state, or if we are running in report mode or check mode.
    
    my ($generate_output, $new_state);
    
    if ( $code ne $pstatus || $REPORT || $CHECK )
    {
	$generate_output = 1;
	$new_state = $summary;
    }
    
    # Otherwise, generate output if the summary has changed from the prior state, but
    # only if the used% of at least one volume has increased.
    
    elsif ( $summary ne $psummary )
    {
	my (%prior_stat, @max_details);
	
	foreach my $entry ( split / - /, $psummary )
	{
	    my ($volume, $used) = split / /, $entry;
	    $prior_stat{$volume} = $used;
	}

	foreach my $v ( @volumes )
	{
	    if ( defined $prior_stat{$v} || defined $over_limit{$v} )
	    {
		if ( defined $prior_stat{$v} && defined $over_limit{$v} &&
		     $over_limit{$v} > $prior_stat{$v} )
		{
		    push @max_details, "$v $over_limit{$v}";
		    $generate_output = 1;
		}
		
		elsif ( defined $prior_stat{$v} )
		{
		    push @max_details, "$v $prior_stat{$v}";
		}
		
		elsif ( defined $over_limit{$v} )
		{
		    push @max_details, "$v $over_limit{$v}";
		    $generate_output = 1;
		}
	    }
	}
	
	$new_state = join ' - ', @max_details;
    }
    
    # If we have determined that output should be generated, do so now.
    
    if ( $generate_output )
    {
	# If the state file has a previous timestamp, state how much time has elapsed
	# since the last state transition.
	
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    LogMessage "$code $elapsed $label";
	}
	
	else
	{
	    LogMessage "$code $label";
	}
	
	AddSubject $code, $subject;
	OutputMessage $_ foreach @output;
	WriteLog $summary if $summary;
	
	# Update the state file if we are running in notify mode, because the
	# notification process depends upon keeping state whereas reporting and checking
	# don't. In particular, we don't want to update the state file in report mode
	# because that could prevent a notification that otherwise would be sent.
	
	if ( $NOTIFY )
	{
	    # Preserve any existing timestamp unless the status code changes.
	    my $new_time = $code eq $pstatus && $ptime > 0 ? $ptime : $curtime;
	    
	    WriteState "$code|$new_time|$new_state|$label";
	}
    }
}


# CheckSystemStatus ( name, parameters )
#
# Check the system load, memory and swap usage, and number of processes.

sub CheckSystemStatus {

    my ($name, $params) = @_;
    
    my (%limit, %critical, %lower);
    
    # Look up the parameters relevant to this entry.
    
    my $command = $params->{sysinfo_command} || $CONFIG->{sysinfo_command} ||
	die "ERROR: you must specify a command to execute with 'sysinfo_command'\n";
    
    $limit{load} = $params->{load_limit};
    $lower{load} = $params->{load_lower};
    $critical{load} = $params->{load_critical};
    $limit{mem} = $params->{mem_limit};
    $lower{mem} = $params->{mem_lower};
    $critical{mem} = $params->{mem_critical};
    $limit{swap} = $params->{swap_limit};
    $lower{swap} = $params->{swap_lower};
    $critical{swap} = $params->{swap_critical};
    $limit{procs} = $params->{procs_limit};
    $lower{procs} = $params->{procs_lower};
    $critical{procs} = $params->{procs_critical};
    
    my $label = $params->{label} || $name;
    my $subject = $params->{subject} || $label;
    
    die "ERROR: $name: invalid value '$limit{load}' for 'load_limit', must be a positive number\n"
	if defined $limit{load} && ! $limit{load} > 0;
    
    die "ERROR: $name: invalid value '$limit{mem}' for 'mem_limit' must be a number 1-100\n"
	if defined $limit{mem} && ! ($limit{mem} > 0 && $limit{mem} <= 100);
    
    die "ERROR: $name: invalid value '$limit{swap}' for 'swap_limit'\n"
	if defined $limit{swap} && ! ($limit{swap} > 0 && $limit{swap} =~ /^[\d.]+[GM]?$/);
    
    die "ERROR: $name: invalid value '$limit{procs}' for 'procs_limit'\n"
	if defined $limit{procs} && ! $limit{procs} > 0;
    
    die "ERROR: $name: invalid value '$critical{load}' for 'load_critical'\n"
	if defined $critical{load} && ! $critical{load} > 0;
    
    die "ERROR: $name: invalid value '$critical{mem}' for 'mem_critical'\n"
	if defined $critical{mem} && ! ($critical{mem} > 0 && $critical{mem} <= 100);
    
    die "ERROR: $name: invalid value '$critical{swap}' for 'swap_critical'\n"
	if defined $critical{swap} && ! ($critical{swap} > 0 && $critical{swap} =~ /^[\d.]+[GM]?$/);
    
    die "ERROR: $name: invalid value '$critical{procs}' for 'procs_critical'\n"
	if defined $critical{procs} && ! $critical{procs} > 0;
    
    die "ERROR: $name: invalid value '$lower{load}' for 'load_lower'\n"
	if defined $lower{load} && ! $lower{load} > 0;
    
    die "ERROR: $name: invalid value '$lower{mem}' for 'mem_lower'\n"
	if defined $lower{mem} && ! ($lower{mem} > 0 && $lower{mem} <= 100);
    
    die "ERROR: $name: invalid value '$lower{swap}' for 'swap_lower'\n"
	if defined $lower{swap} && ! ($lower{swap} > 0 && $lower{swap} =~ /^[\d.]+[GM]?$/);
    
    die "ERROR: $name: invalid value '$lower{procs}' for 'procs_lower'\n"
	if defined $lower{procs} && ! $lower{procs} > 0;
    
    my ($swap_absolute);
    
    if ( $limit{swap} =~ /[GM]/ || $critical{swap} =~ /[GM]/ || $lower{swap} =~ /[GM]/ )
    {
	$swap_absolute = 1;
	die "ERROR: swap limits must all be expressed absolutely if one of them is\n"
	    if defined $limit{swap} && $limit{swap} !~ /[GM]/ ||
	    defined $critical{swap} && $critical{swap} !~ /[GM]/ ||
	    defined $lower{swap} && $lower{swap} !~ /[GM]/;
	
	foreach my $hash ( \%limit, \%critical, \%lower )
	{
	    if ( $hash->{swap} =~ /(.*)([GM])/ )
	    {
		if ( $1 eq 'M' )
		{
		    $hash->{swap} = $1 * 1;
		}
		
		else
		{
		    $hash->{swap} = $1 * 1024;
		}
	    }
	}
    }
    
    # Run the indicated command.
    
    my ($response, $code, %stat, %over_limit, @details, @output);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    else
    {
	$code = 'OK';
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the state file are as follows:
    # 
    # 1. The previous status of the service (OK, WARN, or CRITICAL)
    # 2. The timestamp at which that result was first observed
    # 3. A summary of all volumes whose status is WARN or FULL
    # 4. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $psummary) = split /[|]/, $prior;
    
    # Parse the output, looking for indications that the system status is dangerous.
    
    # a) Look for load average.
    
    # If the command is 'top' or 'uptime', use the 5-minute load average.
    
    if ( $response =~ m{ \bload \s average : \s+ \d[\d.]* .*? (\d[\d.]*) }xmi )
    {
	$stat{load} = $1;
    }
    
    # If the command is 'landscape-sysinfo', only one load average is given.
    
    elsif ( $response =~ m{ \bsystem \s load : \s+ ([\d.]+) }xmi )
    {
	$stat{load} = $1;
    }
    
    # b) Look for memory usage.
    
    # If the command is 'top' or 'free', the stats may come in different orders. We
    # don't care what units the report is using, because we only care about the ratio of
    # used to total.
    
    if ( $response =~ m{ \btotal\b .* \bfree\b .* \bused\b }xmi &&
	 $response =~ m{ \bmem \s* : \s+ (\d[\d.]*) .*? (\d[\d.]*) .*? (\d[\d.]*) }xmi )
    {
	$stat{mem} = ($1 > 0) ? int($3 / $1 * 1000) / 10 : 0;
    }

    elsif ( $response =~ m{ \btotal\b .* \bused\b .* \bfree\b }xmi &&
	    $response =~ m{ \bmem \s* : \s+ (\d[\d.]*) .*? (\d[\d.]*) .*? (\d[\d.]*) }xmi )
    {
	$stat{mem} = ($1 > 0) ? int($2 / $1 * 1000) / 10 : 0;
    }
    
    # If the command is 'landscape-sysinfo', only a used percentage is given.
    
    elsif ( $response =~ m{ memory \s usage : \s+ ([\d.]+)% }xmi )
    {
	$stat{mem} = $1;
    }
    
    # c) Look for swap usage.
    
    # For absolute swap, assume megabytes. So use appropriate options when specifying
    # the command. This option is incompatible with 'landscape-sysinfo'.
    
    if ( $swap_absolute )
    {
	if ( $response =~ m{ \btotal\b .* \bfree\b .* \bused\b }xmi &&
	     $response =~ m{ \bswap \s* : \s+ (\d[\d.]*) .*? (\d[\d.]*) .*? (\d[\d.]*) }xmi )
	{
	    $stat{swap} = $3;
	}
	
	elsif ( $response =~ m{ \btotal\b .* \bused\b .* \bfree\b }xmi &&
		$response =~ m{ \bswap \s* : \s+ (\d[\d.]*) .*? (\d[\d.]*) .*? (\d[\d.]*) }xmi )
	{
	    $stat{swap} = $2;
	}
    }
    
    # For swap percentage, we don't care about the units because we are reporting the
    # ratio of used to total.
    
    else
    {
	if ( $response =~ m{ \btotal\b .* \bfree\b .* \bused\b }xmi &&
	     $response =~ m{ \bswap \s* : \s+ (\d[\d.]*) .*? (\d[\d.]*) .*? (\d[\d.]*) }xmi )
	{
	    $stat{swap} = ($1 > 0) ? int($3 / $1 * 1000) / 10 : 0;
	}
	
	elsif ( $response =~ m{ \btotal\b .* \bused\b .* \bfree\b }xmi &&
		$response =~ m{ \bswap \s* : \s+ (\d[\d.]*) .*? (\d[\d.]*) .*? (\d[\d.]*) }xmi )
	{
	    $stat{swap} = ($1 > 0) ? int($2 / $1 * 1000) / 10 : 0;
	}
	
	# If the command is 'landscape-sysinfo', only a used percentage is given.
	
	elsif ( $response =~ m{ swap \s usage : \s+ ([\d.]+)% }xmi )
	{
	    $stat{swap} = $1;
	}
    }
    
    # d) Look for number of processes.
    
    # If the command is 'top'.
    
    if ( $response =~ m{ tasks : \s+ (\d+) }xmi )
    {
	$stat{procs} = $1;
    }

    # If the command is 'landscape-sysinfo'.
    
    elsif ( $response =~ m{ processes : \s+ ([\d.]+) }xmi )
    {
	$stat{procs} = $1;
    }
    
    
    # Now iterate through the statistics and generate the summary details and output lines.
    
    foreach my $s ( 'load', 'mem', 'swap', 'procs' )
    {
	next unless defined $stat{$s};
	
	if ( $critical{$s} && $stat{$s} >= $critical{$s} )
	{
	    $code = 'CRITICAL';
	    push @details, "$s $stat{$s}";
	    push @output, "*** $s $stat{$s} ***";
	    $over_limit{$s} = $stat{$s};
	}
	
	elsif ( $limit{$s} && $stat{$s} >= $limit{$s} )
	{
	    $code = 'WARN' unless $code eq 'CRITICAL';
	    push @details, "$s $stat{$s}";
	    push @output, "* $s $stat{$s} *";
	    $over_limit{$s} = $stat{$s};
	}
	
	elsif ( $pstatus && $pstatus ne 'OK' && $lower{$s} && $stat{$s} > $lower{$s} )
	{
	    $code = 'WARN' unless $code eq 'CRITICAL';
	    push @details, "$s $stat{$s}";
	    push @output, "- $s $stat{$s} -";
	    $over_limit{$s} = $stat{$s};
	}
	
	elsif ( $CHECK || $REPORT )
	{
	    push @output, "$s $stat{$s}";
	}
    }
    
    # Generate a summary which lists every stat that is at or over its limit. This will
    # be be written to the log, and may be used to generate the new state. If none of the
    # stats are at or over limit, @details will be empty.
    
    my $summary = join ' - ', @details;
    
    # Generate output and possibly update the state file if the status code has changed
    # from the prior state, or if we are running in report mode or check mode.
    
    my ($generate_output, $new_state);
    
    if ( $code ne $pstatus || $REPORT || $CHECK )
    {
	$generate_output = 1;
	$new_state = $summary;
    }
    
    # Otherwise, generate output if the summary has changed from the prior state, but
    # only if at least one of the stats has increased beyond its previously reached max
    # value. The new state will contain the max of the prior stat and the new stat for
    # each stat that either was or is over the limit. The reason for this is that don't
    # want to overwhelm the users of this system with notifications. So we only generate
    # a notification when things are getting worse than the previous max level of badness.
    
    elsif ( $summary ne $psummary )
    {
	my (%prior_stat, @max_details);
	
	foreach my $entry ( split / - /, $psummary )
	{
	    my ($s, $value) = split / /, $entry;
	    $prior_stat{$s} = $value;
	}
	
	foreach my $s ( 'load', 'mem', 'swap', 'procs' )
	{
	    if ( defined $prior_stat{$s} || defined $over_limit{$s} )
	    {
		if ( defined $prior_stat{$s} && defined $over_limit{$s} &&
		     $over_limit{$s} > $prior_stat{$s} )
		{
		    push @max_details, "$s $over_limit{$s}";
		    $generate_output = 1;
		}
		
		elsif ( defined $prior_stat{$s} )
		{
		    push @max_details, "$s $prior_stat{$s}";
		}
		
		elsif ( defined $over_limit{$s} )
		{
		    push @max_details, "$s $over_limit{$s}";
		    $generate_output = 1;
		}
	    }
	}
	
	$new_state = join ' - ', @max_details;
    }
    
    # If we have determined that output should be generated, do so now.
    
    if ( $generate_output )
    {
	# If the state file has a previous timestamp, state how much time has elapsed
	# since the last state transition.
	
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    LogMessage "$code $elapsed $label";
	}
	
	else
	{
	    LogMessage "$code $label";
	}
	
	AddSubject $code, $subject;
	OutputMessage $_ foreach @output;
	WriteLog $summary if $summary;
	
	# Update the state file if we are running in notify mode, because the
	# notification process depends upon keeping state whereas reporting and checking
	# don't. In particular, we don't want to update the state file in report mode
	# because that could prevent a notification that otherwise would be sent.
	
	if ( $NOTIFY )
	{
	    # Preserve any existing timestamp unless the status code changes.
	    my $new_time = $code eq $pstatus && $ptime > 0 ? $ptime : $curtime;
	    
	    WriteState "$code|$new_time|$new_state|$label";
	}
    }
}
    

# CheckTest ( name, parameters )
# 
# A check of this type is used for testing purposes. The first time it is
# executed, the status will be OK. If the entry parameter 'cycle' has a positive
# value, then for that many subsequent executions the status will be ERR before
# returning to 'OK'. Subsequent executions will repeat the cycle. If the
# parameter 'cycle' does not have a positive value, the status will always be
# OK.

sub CheckTest {
    
    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $cycle = $params->{cycle} > 0 ? $params->{cycle} + 0 : 0;
    my $label = $params->{label} || $name;
    my $subject = $params->{subject} || $label;
    
    # Open the correct log file and read the prior state of this entry.
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstate, $pcount) = split /[|]/, $prior;
    
    # If the prior state is 'INIT', the new state will be OK.
    
    if ( $pstate eq 'INIT' )
    {
	LogMessage "OK $label";
	AddSubject 'OK', $subject;
	WriteState "OK||$label" if $NOTIFY;
	return;
    }
    
    # If the prior state is 'OK', the new state will be 'ERR' if $cycle is
    # greater than zero.
    
    elsif ( $pstate eq 'OK' && $cycle )
    {
	LogMessage "ERR 1 $label";
	AddSubject 'ERR', $subject;
	WriteState "ERR|1|$label" if $NOTIFY;
	return;
    }
    
    # If the prior state is 'OK' and we are not cycling, generate output only if
    # we are running in report mode.
    
    elsif ( $pstate eq 'OK' )
    {
	OutputMessage "OK $label" if $REPORT || $CHECK;
	AddSubject 'OK', $subject if $REPORT || $CHECK;
	WriteLog "OK $label";
	return;
    }
    
    # Otherwise, we are in the ERR part of the cycle. If the count does not
    # exceed the value of the cycle parameter, generate output only if we are
    # running in report mode.
    
    my $count = $pcount + 1;
    
    if ( $count <= $cycle )
    {
	OutputMessage "ERR $count $label" if $REPORT || $CHECK;
	AddSubject 'ERR', $subject if $REPORT || $CHECK;
	WriteLog "ERR $count $label";
	WriteState "ERR|$count|$label" if $NOTIFY;
    }
    
    # When the count reaches the value of the cycle parameter, set the state
    # back to OK.
    
    else
    {
	LogMessage "OK $label";
	AddSubject 'OK', $subject;
	WriteState "OK||$label" if $NOTIFY;
    }
}


# SendOutput ( )
# 
# Send all output that has been generated so far as a single message, possibly
# with multiple lines.

sub SendOutput {
    
    # Generate a subject for this message, based on the %SUBJECT_CODE and @SUBJECT_ORDER
    # variables.
    
    my $last = '';
    my $summary = '';
    
    foreach my $code ( grep { $_ ne 'OK' } @SUBJECT_CODE )
    {
	$summary .= '; ' if $summary;
	$summary .= "$code $SUBJECT_LABEL{$code}";
    }

    if ( $SUBJECT_LABEL{OK} )
    {
	$summary .= '; ' if $summary;
	$summary .= "OK $SUBJECT_LABEL{OK}";
    }
    
    # my %conditions;
    
    # foreach my $n ( @OUTPUT )
    # {
    # 	if ( $n =~ /^(\w+)/ )
    # 	{
    # 	    $conditions{$1} = 1 unless $1 eq 'OK';
    # 	}
    # }
    
    # my $summary = %conditions ? join(', ', keys %conditions) : 'OK';
    
    my $action = $NOTIFY ? 'Notify'
	       : $REPORT ? 'Report'
	       :           'Check';
    
    # If the 'sendmail' option was given and the 'recipients' configuration
    # setting was set, send any notifications or reports directly via sendmail.
    # But if we are running in test mode, inform the user of the recipient list
    # and write all output to STDOUT.
    
    if ( $SENDMAIL )
    {
	my $recipients = $CONFIG->{recipients};
	
	# If we are running in report mode and recipients_report is also defined,
	# use that instead.
	
	if ( $REPORT && defined $CONFIG->{recipients_report} )
	{
	    $recipients = $CONFIG->{recipients_report};
	}
	
	# Throw an exception if no recipient list was given.
	
	die "ERROR: you must set the configuration variable 'recipients' in order to use sendmail\n"
	    unless $recipients;
	
	# If the recipient list is '$xxx', then get the recipient from the
	# environment variable xxx or else throw an exception.
	
	if ( $recipients =~ / ^ \$ (\w+) $ /x )
	{
	    $recipients = $ENV{$1} or
		die "ERROR: you must set the environment variable '$1'\n";
	}
	
	elsif ( $recipients =~ /^\$/ )
	{
	    die "ERROR: invalid value for 'recipients' in $CONFIG_FILE\n";
	}
	
	# If we are running in test mode, inform the user of where the output
	# would go and write it directly to STDOUT.
	
	if ( $TEST )
	{
	    my $flag = $CONFIG->{envelope_from} ? " -f $CONFIG->{envelope_from}" : '';
	    say STDERR "Output would be sent via sendmail$flag";
	    say STDERR "To: $recipients";
	    say STDERR "From: $CONFIG->{from}" if $CONFIG->{from};
	    
	    if ( @OUTPUT )
	    {
		say STDOUT "$action $summary";
		say STDOUT $_ foreach @OUTPUT;
	    }
	    
	    else
	    {
		say STDERR "No output";
	    }
	}
	
	# Otherwise, open a pipe to sendmail and write the output to it. If the
	# setting 'envelope_from' has a non-empty value, use the sendmail -f flag.
	# If the setting 'from' has a non-empty value, include a 'From:' header.
	
	else
	{
	    my $from = '';
	    $from = "-f $CONFIG->{envelope_from}" if $CONFIG->{envelope_from};
	    
	    open(my $sendmail, '|-', "sendmail $from $recipients") or 
		die "ERROR: could not run sendmail: $!\n";
	    
	    say $sendmail "From: $CONFIG->{from}" if $CONFIG->{from};
	    say $sendmail "Subject: $action $summary";
	    say $sendmail "";
	    
	    say $sendmail $_ foreach @OUTPUT;
	    
	    close $sendmail;
	}
    }
    
    # Otherwise, write the subject (summary) line followed by all output to
    # STDOUT.
    
    else
    {
	say STDOUT "$action $summary";
	say STDOUT $_ foreach @OUTPUT;
    }
}


# ComputeElapsed ( time, prevtime )
# 
# Return a string giving the difference between the first argument and the
# second in seconds (s) if less than 60, or in minutes (m) if less than 3600, in
# hours (h) if less than 259200, or in days. Any time that is 5 seconds or less
# before the start of a minute or 5 minutes or less before the start of an hour
# or day is rounded up.

sub ComputeElapsed {
    
    my ($time, $ptime) = @_;
    
    return '?' unless $time > 0 && $ptime > 0 && $time >= $ptime;
    
    my $diff = $time - $ptime;
    
    if ( $diff < 55 )
    {
	return "${diff}s";
    }
    
    elsif ( $diff < 3300 )
    {
	my $min = int(($diff+5)/60);
	return "${min}m";
    }
    
    elsif ( $diff < 258900 )
    {
	my $hrs = int(($diff+300)/3600);
	return "${hrs}h";
    }
    
    else
    {
	my $days = int(($diff+300)/86400);
	return "${days}d";
    }
}


# ReadState ( name, parameters )
# 
# Read the state file for the specified entry, and return its contents.

sub ReadState {
    
    my ($name, $params) = @_;
    
    # If no state file is given, it defaults to nnn_state.txt, where nnn is the
    # name of the entry being checked.
    
    my $filename = $params->{state_file} || "${name}_state.txt";
    
    # Make sure that each entry has a different state file.
    
    if ( $state_uniq{$filename} && $state_uniq{$filename} ne $name )
    {
	die "ERROR: '$state_uniq{$filename}' and '$name' have the same state file '$filename'\n";
    }
    
    $state_uniq{$filename} = $name;
    
    # If 'state_dir' is specified in the configuration file, then state files
    # are located in that directory. Otherwise, they are located in the log
    # directory.
    
    my $dir = $STATE_DIR || $LOG_DIR;
    
    $state_file = resolve_name($filename, $dir);
    
    my ($state_fh, $state);
    
    # If we are running in 'check' mode, read the state file if it exists and is
    # readable. Otherwise, return 'INIT'.
    
    if ( $CHECK )
    {
	if ( open $state_fh, '<', $state_file )
	{
	    $state = <$state_fh>;
	    chomp $state;
	    close $state_fh;
	}
	
	return ($state || 'INIT');
    }
    
    # Otherwise, create the state file if it does not exist. The initial state
    # will be 'INIT'.
    
    unless ( -e $state_file )
    {
	open($state_fh, ">", $state_file) 
	    or die "ERROR: cannot create $state_file: $!\n";
	
	say $state_fh "INIT";
	close($state_fh);
    }
    
    # Read and return the contents of the state file. Throw an exception if the
    # file is not readable or not writable and we are running in notify mode.
    
    -w $state_file or ! $NOTIFY
	or die "ERROR: cannot write $state_file: $!\n";
    
    open($state_fh, "<", $state_file) 
	or die "ERROR: cannot read $state_file: $!\n";
    
    $state = <$state_fh>;
    close $state_fh;
    chomp $state;
    
    return ($state || 'INIT');
}


# WriteState ( new_state )
# 
# If we are running in notify mode, Write the specified contents to
# the file $state_file. If we are in report or check mode, do nothing.

sub WriteState {
    
    my ($new_state) = @_;
    
    return unless $NOTIFY;
    
    if ( $TEST )
    {
	say STDERR "Would write state: $new_state";
	return;
    }
    
    open(my $state_fh, ">", $state_file)
	or die "ERROR: cannot write $state_file: $!\n";
    
    say $state_fh $new_state;
    
    close $state_fh
	or die "ERROR: could not write $state_file: $!\n";
}


# SelectLog ( name, parameters )
# 
# Select the proper log file for the specified entry. If that file is already
# open, then leave it. Otherwise, close the open log file (if any) and open this
# one. But do not open any log file if we are running in either check mode or
# test mode.

sub SelectLog {
    
    my ($name, $params) = @_;
    
    return if $CHECK || $TEST;
    
    my $filename = $params->{log_file} || $DEFAULT_LOG;
    
    my $this_log = resolve_name($filename, $LOG_DIR);
    
    # If this log is already open, we are done. Otherwise, close the currently
    # open log file if any and open the new one.
    
    unless ( $log_file eq $this_log )
    {
	close $log_fh if $log_fh;
	
	$log_file = $this_log;
	
	open $log_fh, '>>', $log_file
	    or die "ERROR: could not write to $log_file: $!\n";
    }
}


# OutputMessage ( message )
# 
# Add the specified line to the output of this command.

sub OutputMessage {
    
    my ($message) = @_;
    
    push @OUTPUT, $message;
}


# LogMessage ( message )
# 
# Add the specified line to the output of this command, and also write it to the
# current log file. If we are running in check mode or test mode, $log_fh will
# be undefined.

sub LogMessage {
    
    my ($message) = @_;
    
    push @OUTPUT, $message;
    say $log_fh "[$timestamp] $REPORT$message" if $log_fh;
}


# AddSubject ( code, subject_label )
#
# Add words to the subject line of the output, based on the code and label.

sub AddSubject {
    
    my ($code, $subject_label) = @_;

    if ( $SUBJECT_LABEL{$code} )
    {
	$SUBJECT_LABEL{$code} .= ", $subject_label";
    }
    
    else
    {
	$SUBJECT_LABEL{$code} = $subject_label;
	push @SUBJECT_CODE, $code;
    }
}


# WriteLog ( message )
# 
# Write the specified line to the current log file, but don't add it to the
# output. If we are running in check mode or test mode, $log_fh will
# be undefined.

sub WriteLog {
    
    my ($message) = @_;
    
    say $log_fh "[$timestamp] $REPORT$message" if $log_fh;    
}


# resolve_name ( name, directory )
# 
# If the specified name is an absolute path or starts with ./ or ../, then
# return it unchanged. Otherwise, return the name relative to the specified
# directory.

sub resolve_name {
    
    my ($filename, $dir) = @_;
    
    if ( $filename =~ qr{ ^[/] | ^ [.][/] | & [.][.][/] }xs )
    {
	return $filename;
    }
    
    else
    {
	return "$dir/$filename";
    }
}


__END__

=head1 NAME

webcheck - check the health of local or remote services

=head1 SYNOPSIS

  webcheck [options] [arguments]

This program is intended to be run as a cron job, in order to notify responsible
personnel when a server is down or is having problems. If one or more arguments
are provided, they cause the corresponding status checks from the configuration
file to be performed. With no arguments, all configured status checks are
performed.

  Options:
    -f         Use the specified configuration file.
    -n         Run in 'notify' mode.
    -r         Run in 'report' mode.
    -t         Run in 'test' mode.
    -s         Direct output to sendmail.
    -h         Print help message.
    -m         Print full documentation.

=head1 OPTIONS

=over 4

=item B<-f, --file>

Use the specified configuration file. The default is ./webcheck.yml.

=item B<-n, --notify>

Run in 'notify' mode. Log all status check results, and save the status
of each entry in its state file. Generate output for each entry whose
status has changed, or when a followup notification is indicated.

=item B<-r, --report>

Run in 'report' mode. Log all status check results, and generate output
for each entry including those whose status is unchanged. Do not alter
the state files.

=item B<-s, --sendmail>

Direct all output to sendmail instead of stdout. The recipient list is given by the
configuration setting 'recipients' or 'recipients_report'. If you do not wish to use
this option, you can instead use cron's facility for directing output to sendmail.

=item B<-t, --test>

Write all output to stdout. Do not send output to sendmail, even if the sendmail
option is also given. Do not alter the state files. Write extra messages to
STDERR that indicate where output would otherwise go and what state would
otherwise be saved.

=item B<-h, --help>

Print a brief help message.

=item B<-m, --man>

Print this documentation.

=back

Single-letter options may be bundled.

=head1 DESCRIPTION

The status checks to be performed are specified by entries in a configuration file.
The format of this file is given in the next section.

The default operation mode is 'check'. In this mode, the result of each status check is
written to stdout. No log entries are written, and no state is saved. This mode can be
used at any time to check the status of the configured services.

In 'notify' mode, each status check result is appended to the log file and the status of
each entry is saved to its state file. A notification message is generated when any of
the statuses change, or when a followup notification is indicated. This program is
intended to be run in notify mode as a cron job every 10 minutes, or as frequently as
necessary for prompt notification of outages. The 'sendmail' option can be used to send
these notifications via the sendmail program. This can be used with email-to-sms
addresses to notify responsible personnel on their phones when a service is down, and/or
to regular e-mail addresses. Alternatively, the cron variable MAILTO can be used for the
same purpose albeit with less flexibility.

In 'report' mode, output is generated for each status check result even if the status is
unchanged. The state files are not updated, but all results are written to the log file.
This program can be run in report mode periodically, perhaps once every few days, to
provide output on a regular basis during times when no outages are detected for long
periods. Otherwise, if something were to prevent this program from running, i.e. an
unexpected change to the crontab file, the people who are supposed to be notified would
not have any easy way to find out. But if the report output does not appear as expected,
that would mean something is wrong.

The 'test' flag can be used to check the destination for notification and report output,
without actually sending any output and without changing the state files.

The motivation for the state files, and for this program in general, is to
provide for quick notification when the status of a service changes, without
flooding the responder with notifications if an abnormal condition persists for
hours. It is recommended to run this program every 10 minutes, or as often as
necessary for prompt notification of problems. The 'followup' setting can be
used to provide additional notifications on a specified pattern when an abnormal
condition persists. For example, "1 24 60" will send a followup notification
at 10 minutes, 4 hours, and 10 hours if an abnormal condition persists that long.

=head1 CONFIGURATION FILE

The configuration file must be in YAML format. The status check entries must be listed
under the top level key 'checks'. The following top level keys are allowed, with the
values interpreted as follows:

=over 4

=item B<log_file>

The name of the log file, defaults to 'webcheck.log'.

=item B<log_dir>

The directory in which the log file is located, defaults to '.'

=item B<state_dir>

The directory in which the state files are located, defaults to the value of
log_dir.

=item B<recipients>

When the 'sendmail' option is specified on the command line, send any generated
output to the specified e-mail address(es) directly using sendmail. Multiple
addresses should be separated by commas. If the value has the form '$ENV{xxx}',
the address list is read from the environment variable xxx.

=item B<recipients_report>

Specifies an alternate email recipient list for report mode.

=item B<from>

Sets the 'From' header when used along with 'recipients'. The value can be any
valid e-mail address.

=item B<url_command>

The command to be used for checking remote services. It should contain the
string '%%', which will be substituted with the url for each entry. The default
is "curl --head --silent '%%'".

=item B<url_followup>

The value must be a list of numbers. For example, if the value is C<'1 6'>,
followup notifications will be sent on the 2nd and 7th times that an abnormal
condition is detected if it persists that long. If the notification interval is
10 minutes, this would cause followup notifications to be sent at 10 minutes and
1 hour.

=item B<df_command>

The command to use for disk space checks. The default is 'df'.

=item B<sysinfo_command>

The command to use for system status checks. There is no default.

=item B<checks>

All status check entries must occur as keys under this. The name of each entry
is its key.

=back

=head2 STATUS CHECK ENTRIES

Several types of status check entries are allowed. Any values specified in an entry
override the corresponding top level values for that entry only.

=head3 Group

An entry with a string value represents a group of other entries. The
value must be a list of entry names separated by spaces. When the group
name is given as a command-line argument, all of the specified checks are
executed.

=head3 Remote web service check

An entry of this type must include the key 'url' or 'url_command'. The specified
command is used to fetch the specified URL, and the response is checked for the
standard http response. A response code of 200 is considered normal, anything else is
abnormal. The following keys are accepted:

=over 4

=item B<url>

The url to be checked. This is required if the url command contains the '%%'
replacement token.

=item B<url_command>

A command to be executed for this entry only.

=item B<url_followup>

A followup pattern for this entry only.

=back

=head3 Disk space check

An entry of this type must include the key 'limit'. The command to be run
defaults to 'df', and the output is scanned for volumes whose used% meets or
exceeds the specified threshold. The following keys are accepted:

=over 4

=item B<limit>

The threshold for a 'WARN' status code (required).

=item B<limit_/var>

The threshold for a particular volume, in this case /var.

=item B<lower>

If the current status code is 'WARN', it will change to 'OK' when the used% reaches or
drops below this value. If not specified, the status will change to 'OK' whenever the
used% drops below the 'limit' value. Using B<lower> can prevent excessive notifications
in situations where the used% oscillates around the B<limit> value.

=item B<lower_/var>

The lower threshold for a particular volume, in this case /var.

=item B<df_command>

The command to be executed, defaults to 'df'.

=item B<ignore>

A regexp used to filter the command result. All lines that match it will be
ignored. These would typically include temporary file systems, snaps, etc.

=back

Whenever any volume exceeds its limit, the aggregate status code will be 'WARN'. If any
volume reaches 100%, the aggregate status code will be 'FULL'. In notify mode, while the
status is 'WARN' or 'FULL', a new notification will be sent out whenever the used% for
any volume exceeds its previous highest recorded value during this episode. When all
volumes return to below their limit (or their lower limit if specified) the status will
return to 'OK'.

=head3 System status check

An entry of this type must include one of the following keys: 'load_limit', 'mem_limit',
'swap_limit', or 'procs_limit'. The command to be run must be specified, since the
available commands and parameters vary from system to system. The output is scanned for
values that exceed the specified limits, and the developer has the goal of accepting as
many different output formats as possible. The following keys are accepted, and the
values must be numbers between 1-100. For the 'mem' and 'swap' parameters, the values
may also be any number followed by 'M' or 'G' to indicate absolute sizes in MiB or GiB.

=over 4

=item B<load_limit>

The status be 'WARN' whenever the load average reaches or exceeds this value.

=item B<load_critical>

If specified, the status be 'CRITICAL' whenever the load average reaches or
exceeds this value.

=item B<load_lower>

If specified, the status will change to 'OK' if it was 'WARN' or 'CRITICAL' and the
load average falls to or below this value. Using this key can prevent
excessive notification in situations where the load average oscillates around the limit
value.

=item B<mem_limit>, B<mem_critical>, B<mem_lower>

The same as above, but for memory used percentage.

=item B<swap_limit>, B<swap_critical>, B<swap_lower>

The same as above, but for swap used percentage.

=item B<procs_limit>, B<procs_critical>, B<procs_lower>

The same as above, but for number of processes.

=back

Whenever any of these statistics exceeds its limit, the aggregate status code will be
'WARN'. If any statistic exceeds its critical threshold, the aggregate status code will be
'CRITICAL'. In notify mode, while the status is 'WARN' or 'CRITICAL', a new notification will be
sent out whenever any of these statistics exceeds its previous highest recorded value
during this episode. When all statistics return to below their limit (or their lower limit
if specified) the aggregate status will return to 'OK'.

=head3 Other allowed keys

Status check entries (other than groups) can also contain any of the following keys:

=over 4

=item B<label>

A label string used for generating output, defaults to the entry name.

=item B<log_file>

Log events associated with this entry to the specified file instead of to the main log
file.

=item B<state_file>

Save the state to the specified file. Default is C<nnn_state.txt>, where nnn is
the name of the entry. Each status check is required to have a unique state file name.

=back

=head1 EXAMPLE

Here is an example configuration file:

  log_dir: logs
  url_command: curl -m 15 --head --silent '%%'
  url_followup: 1 24 60 120 180 240 300 360 420 480
  
  recipients: me@mydomain.com, 608-123-4567@sms.gateway
  from: wc@mydomain.com
  
  checks:
    main:
      url: https://mydomain.com/
      label: website
    
    api:
      url: https://mydomain.com/api/v1/
      label: api

This configuration defines two different checks. If this file is placed in your
home directory as I<webcheck.yml> and you create a sub-directory called I<logs>,
you could then execute it via a crontab line as follows:

  0,10,20,30,40,50 * * * * webcheck -sn all

The C<-sn> flags tell webcheck to run in notify mode and send the output to the
specified recipient list via sendmail. Alternatively, you could also do it as
follows:

  MAILTO=my.address@myservice.com, 608-123-4567@sms.gateway
  0,10,20,30,40,50 * * * * webcheck -n all

You will get an initial notification
message whose output looks like the following:

  Notify OK main, api
  website OK
  api OK

As long as both of the specified URLs continue to return HTTP 200 responses, you
will not get any more messages. If at some point, for example, the api URL becomes
non-responsive, you will get the following message:

  Notify DOWN api
  api DOWN (NOR)

After 10 minutes, according to the followup notification pattern, you will get
the following message:

  Notify DOWN api
  api DOWN 10m (NOR)

Continuing our example, if the service again returns a proper response at the
40 minute mark, you will get:
  
  Notify OK api
  api OK 40m

If at any point you want to check the status of the services directly, you can
use the following command:

  cd; webcheck

or

  webcheck -f ~/.webcheck

The following files will be created in the I<logs> subdirectory:

  webcheck.log
  main_state.txt
  api_state.txt

=cut

