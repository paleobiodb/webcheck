#!/usr/bin/env perl
# 
#     WebCheck - check web services and notify when they are down
# 
# 
# Author: Michael McClennen <mmcclenn@geology.wisc.edu>
# 
# This script is designed to be run periodically as a cron job. Depending on the
# configuration, it can check for an acceptable response from one or more web
# services, and can also check free disk space. Output is written to STDOUT by
# default, which in the context of cron allows for it to be directed to the
# responsible personnel through an email inbox or a text message gateway using
# the MAILTO variable. Output can also be sent directly through sendmail. It is
# recommended that this script be run every 10 minutes, or as often as necessary
# to ensure prompt notification of outages.
# 
# The results of all status checks are written to a log file, and the status of
# each service is also stored in a state file. This persistent state enables an
# abnormal condition to be notified once when it occurs, with a specified
# follow-up notification pattern.
# 
# Originally written in the 1990s.
# Rewritten: 2019-02-25, 2023-12-02


use strict;

use feature 'say';
no warnings 'uninitialized';

use Pod::Usage;
use YAML::Tiny;

our ($VERSION) = '1.0';


# Files and directories, with defaults

my $CONFIG_FILE = 'webcheck.yml';
my $DEFAULT_LOG = 'webcheck.log';
my $LOG_DIR = '.';
my $STATE_DIR;


# Operation modes

my $CHECK;
my $NOTIFY;
my $REPORT = '';
my $SENDMAIL;
my $TEST;


# Other global declarations

my ($log_file, $log_fh, $state_file, $state_fh);

my %state_uniq;

sub output_message;
sub log_message;
sub write_log;
sub write_state;

my %TOPLEVEL = (checks => 1, log_dir => 1, log_file => 1, state_dir => 1,
		recipients => 1, recipients_report => 1, from => 1,
		url_command => 1, url_followup => 1, 
		df_command => 1, df_limit => 1);


# All of the log entries and state entries generated by this run will have a single
# timestamp.

my $curtime = time;
my $timestamp = scalar(localtime);


# Parse the command-line options, if any. See the help message below for a
# description of the options.

my $flags = '';

while ( @ARGV )
{
    if ( $ARGV[0] =~ / ^ - ([cnrst]+) $ /x )
    {
	$flags .= $1;
	shift @ARGV;
    }
    
    if ( $ARGV[0] =~ / ^ - ([cnrst]*) f $ | ^ --file $ /x )
    {
	$flags .= $1; 
	shift @ARGV;
	$CONFIG_FILE = shift @ARGV or die "ERROR: you must specify a configuration file name\n";
    }
    
    elsif ( $ARGV[0] =~ / ^ --file=(.*) /x )
    {
	$CONFIG_FILE = $1 or die "ERROR: you must specify a configuration file name\n";
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --check $ /x )
    {
	$flags .= 'c';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --notify $ /x )
    {
	$flags .= 'n';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --report $ /x )
    {
	$flags .= 'r';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --sendmail $ /x )
    {
	$flags .= 's';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --test $ /x )
    {
	$flags .= 't';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ /^-h$|^--help$/ )
    {
	pod2usage(-exitval => 0, -verbose => 0);
	exit;
    }
    
    elsif ( $ARGV[0] =~ /^-m$|^--man$/ )
    {
	pod2usage(-exitval => 0, -verbose => 2);
	exit;
    }
    
    elsif ( $ARGV[0] eq '-' )
    {
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ /^-/ )
    {
	die "ERROR: unrecognized option '$ARGV[0]'\n";
    }
    
    else
    {
	last;
    }
}

$CHECK = 1 if $flags =~ /c/;
$NOTIFY = 1 if $flags =~ /n/;
$REPORT = 'REPORT ' if $flags =~ /r/;
$SENDMAIL = 1 if $flags =~ /s/;
$TEST = 1 if $flags =~ /t/;

die "ERROR: you may not specify --check and --notify together\n" if $CHECK && $NOTIFY;
die "ERROR: you may not specify --check and --report together\n" if $CHECK && $REPORT;

# The default mode is check unless either notify or report were explicitly specified.

$CHECK = 1 unless $NOTIFY || $REPORT;


# Read and validate the configuration file.

my ($CONFIG, @INDENTED_ENTRIES);

&ReadConfigurationFile($CONFIG_FILE);


# Process the remaining arguments, which should specify entries in the
# configuration file to be checked. If no arguments were given, default to
# 'all'. Any output that is generated will be appended to @OUTPUT.

my @OUTPUT;

push @ARGV, 'all' unless @ARGV;

&PerformStatusChecks(@ARGV);


# If any output was generated, send it out now. Otherwise, exit silently unless
# we are running in test mode.

if ( @OUTPUT || $TEST )
{
    &SendOutput;
}

exit;


# ReadConfigurationFile ( filename )
# 
# Read and parse the specified file, which must be in YAML format. Store the
# configuration variables as a hashref in $CONFIG.

sub ReadConfigurationFile {
    
    my ($filename) = @_;
    
    # Read the specified file, or die if an error occurs.
    
    die "ERROR: could not read $CONFIG_FILE: $!\n" unless -r $CONFIG_FILE;
    
    $CONFIG = YAML::Tiny->read($CONFIG_FILE);
    
    $CONFIG = $CONFIG->[0];
    
    # Validate the file contents.
    
    foreach my $key ( keys $CONFIG->%* )
    {
	warn "WARNING: invalid key '$key' in $CONFIG_FILE\n"
	    unless $TOPLEVEL{$key};
	
	if ( $key eq 'log_dir' && $CONFIG->{$key} )
	{
	    $LOG_DIR = $CONFIG->{$key};
	}
	
	elsif ( $key eq 'state_dir' && $CONFIG->{$key} )
	{
	    $STATE_DIR = $CONFIG->{$key};
	}
	
	elsif ( $key eq 'log_file' && $CONFIG->{$key} )
	{
	    $DEFAULT_LOG = $CONFIG->{$key};
	}
    }
    
    die "ERROR: you must have 'checks' as a top-level key in $CONFIG_FILE\n" 
	unless ref $CONFIG eq 'HASH' && $CONFIG->{checks};

    # Now read the raw file contents, and grab the indented entry names in
    # order. It is important that the checks are always done in the same order
    # so that the notification output will be consistent. The YAML::Tiny module
    # cannot give us the order in which the checks are listed in the file, so we
    # use this hack instead.
    
    open(my $ifh, '<', $CONFIG_FILE) or 
	die "ERROR: could not read $CONFIG_FILE: $!\n";
    
    while ( my $line = <$ifh> )
    {
	if ( $line =~ qr{ ^ \s+ (\S+) : }xs )
	{
	    push @INDENTED_ENTRIES, $1 if ref $CONFIG->{checks}{$1} eq 'HASH';
	}
    }
}


# PerformStatusChecks ( entry... )
# 
# Carry out one or more status checks, using entries specified in the
# configuration file. See the help message for more details.

sub PerformStatusChecks {
    
    my %name_uniq;
    
    # Iterate through the list of arguments provided to this subroutine.
    
 ENTRY:
    while ( @_ )
    {
	my $check_name = shift @_;
	
	# Ignore empty entries, and perform each check only once.
	
	next ENTRY unless $check_name && ! $name_uniq{$check_name};
	
	$name_uniq{$check_name} = 1;
	
	# The keyword 'all' expands to all of the entries under 'checks' in the
	# order in which they appear in the configuration file.
	
	if ( $check_name eq 'all' )
	{
	    unshift @_, grep { $CONFIG->{checks}{$_} } @INDENTED_ENTRIES;
	    next ENTRY;
	}
	
	# Throw an exception if we are asked to perform a nonexistent check.
	
	unless ( exists $CONFIG->{checks}{$check_name} )
	{
	    die "ERROR: could not find '$check_name' in $CONFIG_FILE\n";
	}
	
	# If the check exists but is empty, skip it.
	
	my $specification = $CONFIG->{checks}{$check_name};
	
	next ENTRY unless $specification;
	
	# If the value of the entry is a string, it represents a list of other entries to be
	# checked. So split it on whitespace and replace it in the entry list with a list of the
	# resulting strings.
	
	if ( ! ref $specification )
	{
	    my @list = split /\s+/, $specification;
	    
	    foreach my $e ( reverse @list )
	    {
		unshift @_, $e if $e;
	    }
	    
	    next ENTRY;
	}
	
	# If the entry includes the key 'url' or 'url_command', it represents a server status
	# check.
	
	if ( $specification->{url} || $specification->{url_command} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckWebService($check_name, $specification);
	}
	
	# If the entry includes the key 'limit', it represents a disk space check.
	
	elsif ( $specification->{limit} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckDiskSpace($check_name, $specification);
	}
	
	# If the entry includes the key 'cycle', it can be used to test this
	# system. 
	
	elsif ( defined $specification->{cycle} && $specification->{cycle} ne '' )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckTest($check_name, $specification);
	}
	
	# Otherwise, throw an exception.
	
	else
	{
	    die "ERROR: could not determine entry type for '$check_name' in $CONFIG_FILE\n";
	}
    }
    
    # If a log file has been opened, close it now.
    
    close $log_fh if $log_fh;
}


# CheckWebService ( name, parameters )
# 
# Check the status of a remote server, by fetching a specified URL.

sub CheckWebService {

    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $command = $params->{url_command} || $CONFIG->{url_command} || "curl --head --silent '%%'";
    my $followup = $params->{url_followup} || $CONFIG->{url_followup} || '';
    my $check_url = $params->{url};
    my $label = $params->{label} || $name;
    
    # If the command string contains '%', replace each instance with the value of
    # $check_url.
    
    if ( $command =~ /%%/ )
    {
	unless ( $check_url && $check_url =~ qr{ ^ \w+ :// [\w.:]+ / .* }xs )
	{
	    die "ERROR: $name: '$check_url' does not look like a URL, in $CONFIG_FILE\n";
	}
	
	$command =~ s/%%/$check_url/g;
    }
    
    # Use the indicated command to fetch the specified page. If we don't get a
    # valid HTTP response code, set the code to a string indicating an error.
    # The code EXC indicates that the command could not execute, while NOR could
    # mean anything from the command terminating prematurely to the remote
    # server being completely hung.
    
    my ($response, $code);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    elsif ( $response =~ qr{ ^ HTTP/\d[.]\d \s+ (\d+) }xsi )
    {
	$code = $1;
    }
    
    else
    {
	$code = 'NOR';
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the state file are as follows:
    # 
    # 1. The previous status of the service (OK or DOWN)
    # 2. The time at which that result was first observed
    # 3. The number of DOWN results in a row since the last OK
    # 4. The HTTP response code from the service, or NOR for no response
    # 5. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $pcount, $pcode) = split /[|]/, $prior;
    
    # If the response code is 200 and the prior status is 'OK', then everything
    # is hunky dory. Generate output only if running in report or check mode,
    # but generate a log entry in any mode except check. This should be the case
    # on the vast majority of runs of this script.
    
    if ( $code eq '200' && $pstatus eq 'OK' )
    {
	output_message "OK $label" if $REPORT || $CHECK;
	write_log "OK $label";
	return;
    }
    
    # If the response code is 200 and the prior state is not 'OK', generate a
    # notification that the checked server is okay again.
    
    elsif ( $code eq '200' )
    {
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    log_message "OK $elapsed $label";
	}
	
	else
	{
	    log_message "OK $label";
	}
	
	write_state "OK|$curtime|0|200|$label" if $NOTIFY;
	return;
    }
    
    # If the code is anything else, and the prior status was 'OK', generate an
    # initial notification that something is wrong.
    
    elsif ( ! $pcount > 0 )
    {
	log_message "DOWN $label ($code)";
	write_state "DOWN|$curtime|1|$code|$label" if $NOTIFY;
	return;
    }
    
    # Otherwise, this is a continuing bad status situation. Determine if we
    # should send a followup notification based on the followup pattern for this
    # entry. Compute the elapsed time since the bad status was first noticed,
    # and generate a notification if appropriate.
    
    else
    {
	my $count = $pcount + 1;
	my @followup_times = split /[\s,]+/, $followup;
	my $is_followup;
	
	foreach my $n ( @followup_times )
	{
	    $is_followup = 1 if $n == $pcount;
	}
	
	my $elapsed = ComputeElapsed($curtime, $ptime);
	
	my $message = "DOWN $label $elapsed ($code)";
	
	# Generate output if the new response code is different from the
	# prior code, or if we are running in report mode, or if the count matches
	# one of the numbers specified by the entry parameter 'followup'.
	
	if ( $code ne $pcode || $REPORT || $CHECK || $is_followup )
	{
	    output_message $message;
	}
	
	write_log $message;
	write_state "DOWN|$ptime|$count|$code|$label" if $NOTIFY;
	return;
    }
}


# CheckDiskSpace ( name, parameters )
# 
# Check if any of the local disks are getting full, or do that check on a remote
# server.

sub CheckDiskSpace {
    
    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $command = $params->{df_command} || $CONFIG->{df_command} || 'df';
    my $ignore_entries = $params->{ignore} || "_IGNORE NOTHING_";
    my $default_limit = $params->{limit};
    my $label = $params->{label} || $name;
    
    die "ERROR: $name: invalid limit '$default_limit'\n"
	
	unless $default_limit > 0 && $default_limit <= 100;
    
    
    # Run the indicated command, which will typically be `df` or `ssh ... df`.
    
    my ($response, $code, @details, @volume);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    else
    {
	$code = 'OK';
    }
    
    # Parse the output, looking for lines which indicate a disk that is full
    # past the specified limit.
    
    my @lines = split /\n/, $response;
    
    foreach my $line ( @lines )
    {
	next if $line =~ /$ignore_entries/;
	
	next unless $line =~ qr{ \s (\d+) [%] \s+ ( / \S* ) }xs;
	
	my $used = $1;
	my $volume = $2;
	
	my $limit = $params->{"limit_" . $volume};
	
	$limit = $default_limit unless $limit > 0 && $limit <= 100;
	
	if ( $used eq '100' )
	{
	    $code = 'FULL';
	    push @details, "$volume 100";
	    push @volume, "$volume *** 100";
	}
	
	elsif ( $used >= $limit )
	{
	    $code = 'WARN' unless $code eq 'FULL';
	    push @details, "$volume $used";
	    push @volume, "$volume * $used";
	}
	
	elsif ( $CHECK || $REPORT )
	{
	    push @volume, "$volume $used";
	}
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the sate file are as follows:
    # 
    # 1. The previous status of the service (OK, WARN, or FULL)
    # 2. The timestamp at which that result was first observed
    # 3. A summary of all volumes whose status is WARN or FULL
    # 4. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $psummary) = split /[|]/, $prior;
    
    # Generate a summary which lists the use percentage of every volume that is
    # at or over its limit. This will be used to generate the new status. If
    # none of the volumes are at or over limit, @details will be empty.
    
    my $summary = join ' - ', @details;
    
    # Generate output if the summary has changed from the prior state, or if we
    # are running in report mode or check mode. Update the state file only if we
    # are running in notify mode.
    
    if ( $summary ne $psummary || $code ne $pstatus || $REPORT || $CHECK )
    {
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    log_message "$code $elapsed $label";
	}
	
	else
	{
	    log_message "$code $label";
	}
	
	output_message $_ foreach @volume;
	write_log $summary if $summary;
	
	if ( $NOTIFY )
	{
	    my $newtime = $code eq $pstatus && $ptime > 0 ? $ptime : $curtime;	    
	    write_state "$code|$newtime|$summary|$label";
	}
    }
}


# CheckTest ( name, parameters )
# 
# A check of this type is used for testing purposes. The first time it is
# executed, the status will be OK. If the entry parameter 'cycle' has a positive
# value, then for that many subsequent executions the status will be ERR before
# returning to 'OK'. Subsequent executions will repeat the cycle. If the
# parameter 'cycle' does not have a positive value, the status will always be
# OK.

sub CheckTest {
    
    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $cycle = $params->{cycle} > 0 ? $params->{cycle} + 0 : 0;
    my $label = $params->{label} || $name;
    
    # Open the correct log file and read the prior state of this entry.
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstate, $pcount) = split /[|]/, $prior;
    
    # If the prior state is 'INIT', the new state will be OK.
    
    if ( $pstate eq 'INIT' )
    {
	log_message "OK $label";
	write_state "OK||$label" if $NOTIFY;
	return;
    }
    
    # If the prior state is 'OK', the new state will be 'ERR' if $cycle is
    # greater than zero.
    
    elsif ( $pstate eq 'OK' && $cycle )
    {
	log_message "ERR 1 $label";
	write_state "ERR|1|$label" if $NOTIFY;
	return;
    }
    
    # If the prior state is 'OK' and we are not cycling, generate output only if
    # we are running in report mode.
    
    elsif ( $pstate eq 'OK' )
    {
	output_message "OK $label" if $REPORT || $CHECK;
	write_log "OK $label";
	return;
    }
    
    # Otherwise, we are in the ERR part of the cycle. If the count does not
    # exceed the value of the cycle parameter, generate output only if we are
    # running in report mode.
    
    my $count = $pcount + 1;
    
    if ( $count <= $cycle )
    {
	output_message "ERR $count $label" if $REPORT || $CHECK;
	write_log "ERR $count $label";
	write_state "ERR|$count|$label" if $NOTIFY;
    }
    
    # When the count reaches the value of the cycle parameter, set the state
    # back to OK.
    
    else
    {
	log_message "OK $label";
	write_state "OK||$label" if $NOTIFY;
    }
}


# SendOutput ( )
# 
# Send all output that has been generated so far as a single message, possibly
# with multiple lines.

sub SendOutput {
    
    # Generate a subject for this message. If all of the check results are OK,
    # the subject will be either 'Notify OK', 'Report OK', or 'Check OK'.
    # Otherwise, it will contain a list of the abnormal result codes.
    
    my %conditions;
    
    foreach my $n ( @OUTPUT )
    {
	if ( $n =~ /^(\w+)/ )
	{
	    $conditions{$1} = 1 unless $1 eq 'OK';
	}
    }
    
    my $summary = %conditions ? join(', ', keys %conditions) : 'OK';
    
    my $action = $NOTIFY ? 'Notify'
	       : $REPORT ? 'Report'
	       :           'Check';
    
    # If the 'sendmail' option was given and the 'recipients' configuration
    # setting was set, send any notifications or reports directly via sendmail.
    # But if we are running in test mode, inform the user of the recipient list
    # and write all output to STDOUT.
    
    if ( $SENDMAIL )
    {
	my $recipients = $CONFIG->{recipients};
	
	# If we are running in report mode and recipients_report is also defined,
	# use that instead.
	
	if ( $REPORT && defined $CONFIG->{recipients_report} )
	{
	    $recipients = $CONFIG->{recipients_report};
	}
	
	# Throw an exception if no recipient list was given.
	
	die "ERROR: you must set the configuration variable 'recipients' in order to use sendmail\n"
	    unless $recipients;
	
	# If the recipient list is '$xxx', then get the recipient from the
	# environment variable xxx or else throw an exception.
	
	if ( $recipients =~ / ^ \$ (\w+) $ /x )
	{
	    $recipients = $ENV{$1} or
		die "ERROR: you must set the environment variable '$1'\n";
	}
	
	elsif ( $recipients =~ /^\$/ )
	{
	    die "ERROR: invalid value for 'recipients' in $CONFIG_FILE\n";
	}
	
	# If we are running in test mode, inform the user of where the output
	# would go and write it directly to STDOUT.
	
	if ( $TEST )
	{
	    say STDERR "Output would be sent via sendmail";
	    say STDERR "To: $recipients";
	    say STDERR "From: $CONFIG->{from}" if $CONFIG->{from};
	    
	    if ( @OUTPUT )
	    {
		say STDOUT "$action $summary";
		say STDOUT $_ foreach @OUTPUT;
	    }
	    
	    else
	    {
		say STDERR "No output";
	    }
	}
	
	# Otherwise, open a pipe to sendmail and write the output to it.
	
	else
	{
	    my $from = '';
	    $from = "-f $CONFIG->{from}" if $CONFIG->{from};
	    
	    open(my $sendmail, '|-', "sendmail $from $recipients") or 
		die "ERROR: could not run sendmail: $!\n";
	    
	    # say $sendmail "From: $CONFIG->{from}" if $CONFIG->{from};
	    say $sendmail "Subject: $action $summary";
	    say $sendmail "";
	    
	    say $sendmail $_ foreach @OUTPUT;
	    
	    close $sendmail;
	}
    }
    
    # Otherwise, write the subject (summary) line followed by all output to
    # STDOUT.
    
    else
    {
	say STDOUT "$action $summary";
	say STDOUT $_ foreach @OUTPUT;
    }
}


# ComputeElapsed ( time, prevtime )
# 
# Return a string giving the difference between the first argument and the
# second in seconds (s) if less than 60, or in minutes (m) if less than 3600, in
# hours (h) if less than 259200, or in days. Any time that is 5 seconds or less
# before the start of a minute or 5 minutes or less before the start of an hour
# or day is rounded up.

sub ComputeElapsed {
    
    my ($time, $ptime) = @_;
    
    return '?' unless $time > 0 && $ptime > 0 && $time >= $ptime;
    
    my $diff = $time - $ptime;
    
    if ( $diff < 55 )
    {
	return "${diff}s";
    }
    
    elsif ( $diff < 3300 )
    {
	my $min = int($diff+5/60);
	return "${min}m";
    }
    
    elsif ( $diff < 258900 )
    {
	my $hrs = int(($diff+300)/3600);
	return "${hrs}h";
    }
    
    else
    {
	my $days = int(($diff+300)/86400);
	return "${days}d";
    }
}


# ReadState ( name, parameters )
# 
# Read the state file for the specified entry, and return its contents.

sub ReadState {
    
    my ($name, $params) = @_;
    
    # If no state file is given, it defaults to nnn_state.txt, where nnn is the
    # name of the entry being checked.
    
    my $filename = $params->{state_file} || "${name}_state.txt";
    
    # Make sure that each entry has a different state file.
    
    if ( $state_uniq{$filename} && $state_uniq{$filename} ne $name )
    {
	die "ERROR: '$state_uniq{$filename}' and '$name' have the same state file '$filename'\n";
    }
    
    $state_uniq{$filename} = $name;
    
    # If 'state_dir' is specified in the configuration file, then state files
    # are located in that directory. Otherwise, they are located in the log
    # directory.
    
    my $dir = $STATE_DIR || $LOG_DIR;
    
    $state_file = resolve_name($filename, $dir);
    
    my ($state_fh, $state);
    
    # If we are running in 'check' mode, read the state file if it exists and is
    # readable. Otherwise, return 'INIT'.
    
    if ( $CHECK )
    {
	if ( open $state_fh, '<', $state_file )
	{
	    $state = <$state_fh>;
	    chomp $state;
	    close $state_fh;
	}
	
	return ($state || 'INIT');
    }
    
    # Otherwise, create the state file if it does not exist. The initial state
    # will be 'INIT'.
    
    unless ( -e $state_file )
    {
	open($state_fh, ">", $state_file) 
	    or die "ERROR: cannot create $state_file: $!\n";
	
	say $state_fh "INIT";
	close($state_fh);
    }
    
    # Read and return the contents of the state file. Throw an exception if the
    # file is not readable or not writable and we are running in notify mode.
    
    -w $state_file or ! $NOTIFY
	or die "ERROR: cannot write $state_file: $!\n";
    
    open($state_fh, "<", $state_file) 
	or die "ERROR: cannot read $state_file: $!\n";
    
    $state = <$state_fh>;
    close $state_fh;
    chomp $state;
    
    return ($state || 'INIT');
}


# write_state ( new_state )
# 
# If we are running in notify mode, Write the specified contents to
# the file $state_file. If we are in report or check mode, do nothing.

sub write_state {
    
    my ($new_state) = @_;
    
    return unless $NOTIFY;
    
    if ( $TEST )
    {
	say STDERR "Would write state: $new_state";
	return;
    }
    
    open(my $state_fh, ">", $state_file)
	or die "ERROR: cannot write $state_file: $!\n";
    
    say $state_fh $new_state;
    
    close $state_fh
	or die "ERROR: could not write $state_file: $!\n";
}


# SelectLog ( name, parameters )
# 
# Select the proper log file for the specified entry. If that file is already
# open, then leave it. Otherwise, close the open log file (if any) and open this
# one. But do not open any log file if we are running in either check mode or
# test mode.

sub SelectLog {
    
    my ($name, $params) = @_;
    
    return if $CHECK || $TEST;
    
    my $filename = $params->{log_file} || $DEFAULT_LOG;
    
    my $this_log = resolve_name($filename, $LOG_DIR);
    
    # If this log is already open, we are done. Otherwise, close the currently
    # open log file if any and open the new one.
    
    unless ( $log_file eq $this_log )
    {
	close $log_fh if $log_fh;
	
	$log_file = $this_log;
	
	open $log_fh, '>>', $log_file
	    or die "ERROR: could not write to $log_file: $!\n";
    }
}


# output_message ( message )
# 
# Add the specified line to the output of this command.

sub output_message {
    
    my ($message) = @_;
    
    push @OUTPUT, $message;
}


# log_message ( message )
# 
# Add the specified line to the output of this command, and also write it to the
# current log file. If we are running in check mode or test mode, $log_fh will
# be undefined.

sub log_message {
    
    my ($message) = @_;
    
    push @OUTPUT, $message;
    say $log_fh "[$timestamp] $REPORT$message" if $log_fh;
}


# write_log ( message )
# 
# Write the specified line to the current log file, but don't add it to the
# output. If we are running in check mode or test mode, $log_fh will
# be undefined.

sub write_log {
    
    my ($message) = @_;
    
    say $log_fh "[$timestamp] $REPORT$message" if $log_fh;    
}


# resolve_name ( name, directory )
# 
# If the specified name is an absolute path or starts with ./ or ../, then
# return it unchanged. Otherwise, return the name relative to the specified
# directory.

sub resolve_name {
    
    my ($filename, $dir) = @_;
    
    if ( $filename =~ qr{ ^[/] | ^ [.][/] | & [.][.][/] }xs )
    {
	return $filename;
    }
    
    else
    {
	return "$dir/$filename";
    }
}


__END__

=head1 NAME

webcheck - check the health of local or remote services

=head1 SYNOPSIS

  webcheck [options] [arguments]

This program is intended to be run as a cron job, in order to notify responsible
personnel when a server is down or is having problems. If one or more arguments
are provided, they cause the corresponding status checks from the configuration
file to be performed. With no arguments, all configured status checks are
performed.

  Options:
    -f         Use the specified configuration file.
    -n         Run in 'notify' mode.
    -r         Run in 'report' mode.
    -t         Run in 'test' mode.
    -s         Direct output to sendmail.
    -h         Print help message.
    -m         Print full documentation.

=head1 OPTIONS

=over 4

=item B<-f, --file>

Use the specified configuration file. The default is ./webcheck.yml.

=item B<-n, --notify>

Run in 'notify' mode. Log all status check results, and save the status
of each entry in its state file. Generate output for each entry whose
status has changed, or when a followup notification is indicated.

=item B<-r, --report>

Run in 'report' mode. Log all status check results, and generate output
for each entry including those whose status is unchanged. Do not alter
the state files.

=item B<-s, --sendmail>

Direct all output to sendmail instead of stdout. The recipient list
is given by the configuration setting 'recipients' or 'recipients_report'.

=item B<-t, --test>

Write all output to stdout. Do not send output to sendmail, even if the sendmail
option is also given. Do not alter the state files. Write extra messages to
STDERR that indicate where output would otherwise go and what state would
otherwise be saved.

=item B<-h, --help>

Print a brief help message.

=item B<-m, --man>

Print this documentation.

=back

Single-letter options may be bundled.

=head1 DESCRIPTION

The status checks to be performed are specified by entries in a configuration file.
The format of this file is given in the next section.

The default operation mode is 'check'. In this mode, the result of each status check is
written to stdout. No log entries are written, and no state is saved. This mode can be
used at any time to check the status of the configured services.

In 'notify' mode, each status check result is appended to the log file and the status of
each entry is saved to its state file. A notification message is generated when any of
the statuses change, or when a followup notification is indicated. This program is
intended to be run in notify mode as a cron job every 10 minutes, or as frequently as
necessary for prompt notification of outages. The 'sendmail' option can be used to send
these notifications via the sendmail program. This can be used with email-to-sms
addresses to notify responsible personnel on their phones when a service is down, and/or
to regular e-mail addresses. Alternatively, the cron variable MAILTO can be used for the
same purpose albeit with less flexibility.

In 'report' mode, output is generated for each status check result even if the status is
unchanged. The state files are not updated, but all results are written to the log file.
This program can be run in report mode periodically, perhaps once every few days, to
provide output on a regular basis during times when no outages are detected for long
periods. Otherwise, if something were to prevent this program from running, i.e. an
unexpected change to the crontab file, the people who are supposed to be notified would
not have any easy way to find out. But if the report output does not appear as expected,
that would mean something is wrong.

The 'test' flag can be used to check the destination for notification and report output,
without actually sending any output and without changing the state files.

The motivation for the state files, and for this program in general, is to
provide for quick notification when the status of a service changes, without
flooding the responder with notifications if an abnormal condition persists for
hours. It is recommended to run this program every 10 minutes, or as often as
necessary for prompt notification of problems. The 'followup' setting can be
used to provide additional notifications on a specified pattern when an abnormal
condition persists. For example, "1 24 60" will send a followup notification
at 10 minutes, 4 hours, and 10 hours if an abnormal condition persists that long.

=head1 CONFIGURATION FILE

The configuration file must be in YAML format. The status check entries must be listed
under the top level key 'checks'. The following top level keys are allowed, with the
values interpreted as follows:

=over 4

=item B<log_file>

The name of the log file, defaults to 'webcheck.log'.

=item B<log_dir>

The directory in which the log file is located, defaults to '.'

=item B<state_dir>

The directory in which the state files are located, defaults to the value of
log_dir.

=item B<recipients>

When the 'sendmail' option is specified on the command line, send any generated
output to the specified e-mail address(es) directly using sendmail. Multiple
addresses should be separated by commas. If the value has the form '$ENV{xxx}',
the address list is read from the environment variable xxx.

=item B<recipients_report>

Specifies an alternate email recipient list for report mode.

=item B<from>

Sets the 'From' header when used along with 'recipients'. The value can be any
valid e-mail address.

=item B<url_command>

The command to be used for checking remote services. It should contain the
string '%%', which will be substituted with the url for each entry. The default
is "curl --head --silent '%%'".

=item B<url_followup>

The value must be a list of numbers. For example, if the value is C<'1 6'>,
followup notifications will be sent on the 2nd and 7th times that an abnormal
condition is detected if it persists that long. If the notification interval is
10 minutes, this would cause followup notifications to be sent at 10 minutes and
1 hour.

=item B<checks>

All status check entries must occur as keys under this. The name of each entry
is its key.

=back

=head2 STATUS CHECK ENTRIES

Three types of entries are allowed, plus one more type used only in build tests.
Any values specified in an entry override the corresponding top level values for
that entry only.

=head3 Group

An entry with a string value represents a group of other entries. The
value must be a list of entry names separated by spaces. When the group
name is given as a command-line argument, all of the specified checks are
executed.

=head3 Remote service check

An entry of this type must include the key 'url' or 'url_command'. The specified
command is used to fetch the specified URL, and the response is checked for the
standard http response. A response code of 200 is considered normal, anything else is
abnormal. The following keys are accepted:

=over 4

=item B<url>

The url to be checked. This is required if the url command contains the '%%'
replacement token.

=item B<url_command>

A command to be executed for this entry only.

=item B<url_followup>

A followup pattern for this entry only.

=item B<label>

A label string used for generating output, defaults to the entry name.

=item B<log_file>

Log this entry to the specified file instead of to the main one.

=item B<state_file>

Save the state to the specified file. Default is C<nnn_state.txt>, where nnn is
the name of the entry.

=back

=head3 Disk space check

An entry of this type must include the key 'limit'. The command to be run
defaults to 'df', and the output is scanned for volumes whose use% meets or
exceeds the specified threshold. The following keys are accepted:

=over 4

=item B<limit>

The threshold for notification of use% (required).

=item B<limit_/var>

The threshold for notification of a particular volume, in this case /var.

=item B<df_command>

A command to be executed, defaults to 'df'.

=item B<ignore>

A regexp used to filter the command result. All lines that match it will be
ignored. These would typically include temporary file systems, snaps, etc.

=item B<label>

A label string used for generating output, defaults to the entry name.

=item B<log_file>

Log this entry to the specified file instead of to the main one.

=item B<state_file>

Save the state to the specified file. Default is C<nnn_state.txt>, where nnn is
the name of the entry.

=back

=head1 EXAMPLE

Here is an example configuration file:

  log_dir: logs
  url_command: curl -m 15 --head --silent '%%'
  url_followup: 1 24 60 120 180 240 300 360 420 480
  
  recipients: my.address@myservice.com, 608-123-4567@sms.gateway
  from: wc@myservice.com
  
  checks:
    main:
      url: https://myservice.com/
      label: website
    
    api:
      url: https://dev.myservice.com/api/v1/
      label: api

This configuration defines two different checks. If this file is placed in your
home directory as I<webcheck.yml> and you create a sub-directory called I<logs>,
you could then execute it via a crontab line as follows:

  0,10,20,30,40,50 * * * * webcheck -sn all

The C<-sn> flags tell webcheck to run in notify mode and send the output to the
specified recipient list via sendmail. Alternatively, you could also do it as
follows:

  MAILTO=my.address@myservice.com, 608-123-4567@sms.gateway
  0,10,20,30,40,50 * * * * webcheck -n all

You will get an initial notification
message whose output looks like the following:

  Notify OK
  website OK
  api OK

As long as both of the specified URLs continue to return HTTP 200 responses, you
will not get any more messages. If at some point, for example, the api URL becomes
non-responsive, you will get the following message:

  Notify DOWN
  api DOWN (NOR)

After 10 minutes, according to the followup notification pattern, you will get
the following message:

  Notify DOWN
  api DOWN 10m (NOR)

Continuing our example, if the service again returns a proper response at the
40 minute mark, you will get:
  
  Notify OK
  api OK 40m

If at any point you want to check the status of the services directly, you can
use the following command:

  cd; webcheck

or

  webcheck -f ~/.webcheck

The following files will be created in the I<logs> subdirectory:

  webcheck.log
  main_state.txt
  api_state.txt

=cut

