#!/usr/bin/env perl
# 
#     WebCheck - check web services and notify when they are down
# 
# 
# Author: Michael McClennen <mmcclenn@geology.wisc.edu>
# 
# This script is designed to be run periodically as a cron job. Depending on the
# configuration, it can check for an acceptable response from one or more web
# services, and can also check free disk space. Output is written to STDOUT by
# default, which in the context of cron allows for it to be directed to the
# responsible personnel through an email inbox or a text message gateway using
# the MAILTO variable. Output can also be sent directly through sendmail. It is
# recommended that this script be run every 10 minutes, or as often as necessary
# to ensure prompt notification of outages.
# 
# The results of all status checks are written to a log file, and the status of
# each service is also stored in a state file. This persistent state enables an
# abnormal condition to be notified once when it occurs, with a specified
# follow-up notification pattern.
# 
# Originally written in the 1990s.
# Rewritten: 2019-02-25, 2023-12-02


use strict;

use feature 'say';
no warnings 'uninitialized';

use YAML::Tiny;


# Files and directories, with defaults

my $CONFIG_FILE = 'webcheck.yml';
my $DEFAULT_LOG = 'webcheck.log';
my $LOG_DIR = '.';
my $STATE_DIR;


# Operation modes

my $CHECK;
my $NOTIFY;
my $REPORT = '';
my $SENDMAIL;
my $TEST;


# Other global declarations

my ($log_file, $log_fh, $state_file, $state_fh);

my %state_uniq;

sub output_message;
sub log_message;
sub write_log;
sub write_state;

my %TOPLEVEL = (checks => 1, log_dir => 1, log_file => 1, state_dir => 1,
		recipients => 1, recipients_report => 1, from => 1,
		url_command => 1, url_followup => 1, 
		df_command => 1, df_limit => 1);


# All of the log entries and state entries generated by this run will have a single
# timestamp.

my $curtime = time;
my $timestamp = scalar(localtime);


# Parse the command-line options, if any. See the help message below for a
# description of the options.

my $flags = '';

while ( @ARGV )
{
    if ( $ARGV[0] =~ / ^ - ([cnrst]+) $ /x )
    {
	$flags .= $1;
	shift @ARGV;
    }
    
    if ( $ARGV[0] =~ / ^ - ([cnrst]*) f $ | ^ --file $ /x )
    {
	$flags .= $1; 
	shift @ARGV;
	$CONFIG_FILE = shift @ARGV or die "ERROR: you must specify a configuration file name\n";
    }
    
    elsif ( $ARGV[0] =~ / ^ --file=(.*) /x )
    {
	$CONFIG_FILE = $1 or die "ERROR: you must specify a configuration file name\n";
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --check $ /x )
    {
	$flags .= 'c';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --notify $ /x )
    {
	$flags .= 'n';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --report $ /x )
    {
	$flags .= 'r';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --sendmail $ /x )
    {
	$flags .= 's';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ / ^ --test $ /x )
    {
	$flags .= 't';
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ /^-h$|^--help$/ )
    {
	&help_message;
	exit;
    }
    
    elsif ( $ARGV[0] eq '-' )
    {
	shift @ARGV;
    }
    
    elsif ( $ARGV[0] =~ /^-/ )
    {
	die "ERROR: unrecognized option '$ARGV[0]'\n";
    }
    
    else
    {
	last;
    }
}

$CHECK = 1 if $flags =~ /c/;
$NOTIFY = 1 if $flags =~ /n/;
$REPORT = 'REPORT ' if $flags =~ /r/;
$SENDMAIL = 1 if $flags =~ /s/;
$TEST = 1 if $flags =~ /t/;

die "ERROR: you may not specify --check and --notify together\n" if $CHECK && $NOTIFY;
die "ERROR: you may not specify --check and --report together\n" if $CHECK && $REPORT;

# The default mode is check unless either notify or report were explicitly specified.

$CHECK = 1 unless $NOTIFY || $REPORT;


# Read and validate the configuration file.

my ($CONFIG, @INDENTED_ENTRIES);

&ReadConfigurationFile($CONFIG_FILE);


# Process the remaining arguments, which should specify entries in the
# configuration file to be checked. If no arguments were given, default to
# 'all'. Any output that is generated will be appended to @OUTPUT.

my @OUTPUT;

push @ARGV, 'all' unless @ARGV;

&PerformStatusChecks(@ARGV);


# If any output was generated, send it out now. Otherwise, exit silently unless
# we are running in test mode.

if ( @OUTPUT || $TEST )
{
    &SendOutput;
}

exit;


# ReadConfigurationFile ( filename )
# 
# Read and parse the specified file, which must be in YAML format. Store the
# configuration variables as a hashref in $CONFIG.

sub ReadConfigurationFile {
    
    my ($filename) = @_;
    
    # Read the specified file, or die if an error occurs.
    
    die "ERROR: could not read $CONFIG_FILE: $!" unless -r $CONFIG_FILE;
    
    $CONFIG = YAML::Tiny->read($CONFIG_FILE);
    
    $CONFIG = $CONFIG->[0];
    
    # Validate the file contents.
    
    die "ERROR: you must have 'checks' as a top-level key in $CONFIG_FILE\n" 
	unless ref $CONFIG eq 'HASH' && $CONFIG->{checks};

    foreach my $key ( keys $CONFIG->%* )
    {
	warn "WARNING: invalid key '$key' in $CONFIG_FILE\n"
	    unless $TOPLEVEL{$key};
	
	if ( $key eq 'log_dir' && $CONFIG->{$key} )
	{
	    $LOG_DIR = $CONFIG->{$key};
	}
	
	elsif ( $key eq 'state_dir' && $CONFIG->{$key} )
	{
	    $STATE_DIR = $CONFIG->{$key};
	}
	
	elsif ( $key eq 'log_file' && $CONFIG->{$key} )
	{
	    $DEFAULT_LOG = $CONFIG->{$key};
	}
    }
    
    # Now read the raw file contents, and grab the indented entry names in
    # order. It is important that the checks are always done in the same order
    # so that the notification output will be consistent. The YAML::Tiny module
    # cannot give us the order in which the checks are listed in the file, so we
    # use this hack instead.
    
    open(my $ifh, '<', $CONFIG_FILE) or 
	die "ERROR: could not read $CONFIG_FILE: $!";
    
    while ( my $line = <$ifh> )
    {
	if ( $line =~ qr{ ^ \s+ (\S+) : }xs )
	{
	    push @INDENTED_ENTRIES, $1 if ref $CONFIG->{checks}{$1} eq 'HASH';
	}
    }
}


# PerformStatusChecks ( entry... )
# 
# Carry out one or more status checks, using entries specified in the
# configuration file. See the help message for more details.

sub PerformStatusChecks {
    
    my %name_uniq;
    
    # Iterate through the list of arguments provided to this subroutine.
    
 ENTRY:
    while ( @_ )
    {
	my $check_name = shift @_;
	
	# Ignore empty entries, and perform each check only once.
	
	next ENTRY unless $check_name && ! $name_uniq{$check_name};
	
	$name_uniq{$check_name} = 1;
	
	# The keyword 'all' expands to all of the entries under 'checks' in the
	# order in which they appear in the configuration file.
	
	if ( $check_name eq 'all' )
	{
	    unshift @_, grep { $CONFIG->{checks}{$_} } @INDENTED_ENTRIES;
	    next ENTRY;
	}
	
	# Throw an exception if we are asked to perform a nonexistent check.
	
	unless ( exists $CONFIG->{checks}{$check_name} )
	{
	    die "ERROR: could not find '$check_name' in $CONFIG_FILE\n";
	}
	
	# If the check exists but is empty, skip it.
	
	my $specification = $CONFIG->{checks}{$check_name};
	
	next ENTRY unless $specification;
	
	# If the value of the entry is a string, it represents a list of other entries to be
	# checked. So split it on whitespace and replace it in the entry list with a list of the
	# resulting strings.
	
	if ( ! ref $specification )
	{
	    my @list = split /\s+/, $specification;
	    
	    foreach my $e ( reverse @list )
	    {
		unshift @_, $e if $e;
	    }
	    
	    next ENTRY;
	}
	
	# If the entry includes the key 'url' or 'url_command', it represents a server status
	# check.
	
	if ( $specification->{url} || $specification->{url_command} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckWebService($check_name, $specification);
	}
	
	# If the entry includes the key 'limit', it represents a disk space check.
	
	elsif ( $specification->{limit} )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckDiskSpace($check_name, $specification);
	}
	
	# If the entry includes the key 'cycle', it can be used to test this
	# system. 
	
	elsif ( defined $specification->{cycle} && $specification->{cycle} ne '' )
	{
	    say STDERR "Performing check '$check_name'" if $TEST;
	    CheckTest($check_name, $specification);
	}
	
	# Otherwise, throw an exception.
	
	else
	{
	    die "ERROR: could not determine entry type for '$check_name' in $CONFIG_FILE\n";
	}
    }
    
    # If a log file has been opened, close it now.
    
    close $log_fh if $log_fh;
}


# CheckWebService ( name, parameters )
# 
# Check the status of a remote server, by fetching a specified URL.

sub CheckWebService {

    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $command = $params->{url_command} || $CONFIG->{url_command} || "curl --head --silent '%%'";
    my $followup = $params->{url_followup} || $CONFIG->{url_followup} || '';
    my $check_url = $params->{url};
    my $label = $params->{label} || $name;
    
    # If the command string contains '%', replace each instance with the value of
    # $check_url.
    
    if ( $command =~ /%%/ )
    {
	unless ( $check_url && $check_url =~ qr{ ^ \w+ :// [\w.:]+ / .* }xs )
	{
	    die "ERROR: $name: '$check_url' does not look like a URL, in $CONFIG_FILE\n";
	}
	
	$command =~ s/%%/$check_url/g;
    }
    
    # Use the indicated command to fetch the specified page. If we don't get a
    # valid HTTP response code, set the code to a string indicating an error.
    # The code EXC indicates that the command could not execute, while NOR could
    # mean anything from the command terminating prematurely to the remote
    # server being completely hung.
    
    my ($response, $code);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    elsif ( $response =~ qr{ ^ HTTP/\d[.]\d \s+ (\d+) }xsi )
    {
	$code = $1;
    }
    
    else
    {
	$code = 'NOR';
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the state file are as follows:
    # 
    # 1. The previous status of the service (OK or DOWN)
    # 2. The time at which that result was first observed
    # 3. The number of DOWN results in a row since the last OK
    # 4. The HTTP response code from the service, or NOR for no response
    # 5. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $pcount, $pcode) = split /[|]/, $prior;
    
    # If the response code is 200 and the prior status is 'OK', then everything
    # is hunky dory. Generate output only if running in report or check mode,
    # but generate a log entry in any mode except check. This should be the case
    # on the vast majority of runs of this script.
    
    if ( $code eq '200' && $pstatus eq 'OK' )
    {
	output_message "OK $label" if $REPORT || $CHECK;
	write_log "OK $label";
	return;
    }
    
    # If the response code is 200 and the prior state is not 'OK', generate a
    # notification that the checked server is okay again.
    
    elsif ( $code eq '200' )
    {
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    log_message "OK $elapsed $label";
	}
	
	else
	{
	    log_message "OK $label";
	}
	
	write_state "OK|$curtime|0|200|$label" if $NOTIFY;
	return;
    }
    
    # If the code is anything else, and the prior status was 'OK', generate an
    # initial notification that something is wrong.
    
    elsif ( ! $pcount > 0 )
    {
	log_message "DOWN $label ($code)";
	write_state "DOWN|$curtime|1|$code|$label" if $NOTIFY;
	return;
    }
    
    # Otherwise, this is a continuing bad status situation. Determine if we
    # should send a followup notification based on the followup pattern for this
    # entry. Compute the elapsed time since the bad status was first noticed,
    # and generate a notification if appropriate.
    
    else
    {
	my $count = $pcount + 1;
	my @followup_times = split /[\s,]+/, $followup;
	my $is_followup;
	
	foreach my $n ( @followup_times )
	{
	    $is_followup = 1 if $n == $pcount;
	}
	
	my $elapsed = ComputeElapsed($curtime, $ptime);
	
	my $message = "DOWN $label $elapsed ($code)";
	
	# Generate output if the new response code is different from the
	# prior code, or if we are running in report mode, or if the count matches
	# one of the numbers specified by the entry parameter 'followup'.
	
	if ( $code ne $pcode || $REPORT || $CHECK || $is_followup )
	{
	    output_message $message;
	}
	
	write_log $message;
	write_state "DOWN|$ptime|$count|$code|$label" if $NOTIFY;
	return;
    }
}


# CheckDiskSpace ( name, parameters )
# 
# Check if any of the local disks are getting full, or do that check on a remote
# server.

sub CheckDiskSpace {
    
    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $command = $params->{df_command} || $CONFIG->{df_command} || 'df';
    my $ignore_entries = $params->{ignore} || "_IGNORE NOTHING_";
    my $default_limit = $params->{limit};
    my $label = $params->{label} || $name;
    
    die "ERROR: $name: invalid limit '$default_limit'\n"
	
	unless $default_limit > 0 && $default_limit <= 100;
    
    
    # Run the indicated command, which will typically be `df` or `ssh ... df`.
    
    my ($response, $code, @details, @volume);
    
    eval {
	$response = `$command`;
    };
    
    if ( $! )
    {
	$code = 'EXC';
    }
    
    else
    {
	$code = 'OK';
    }
    
    # Parse the output, looking for lines which indicate a disk that is full
    # past the specified limit.
    
    my @lines = split /\n/, $response;
    
    foreach my $line ( @lines )
    {
	next if $line =~ /$ignore_entries/;
	
	next unless $line =~ qr{ \s (\d+) [%] \s+ ( / \S* ) }xs;
	
	my $used = $1;
	my $volume = $2;
	
	my $limit = $params->{"limit_" . $volume};
	
	$limit = $default_limit unless $limit > 0 && $limit <= 100;
	
	if ( $used eq '100' )
	{
	    $code = 'FULL';
	    push @details, "$volume 100";
	    push @volume, "$volume *** 100";
	}
	
	elsif ( $used >= $limit )
	{
	    $code = 'WARN' unless $code eq 'FULL';
	    push @details, "$volume $used";
	    push @volume, "$volume * $used";
	}
	
	elsif ( $CHECK || $REPORT )
	{
	    push @volume, "$volume $used";
	}
    }
    
    # Open the correct log file and read the prior state of this entry. The
    # fields of the sate file are as follows:
    # 
    # 1. The previous status of the service (OK, WARN, or FULL)
    # 2. The timestamp at which that result was first observed
    # 3. A summary of all volumes whose status is WARN or FULL
    # 4. The service label
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstatus, $ptime, $psummary) = split /[|]/, $prior;
    
    # Generate a summary which lists the use percentage of every volume that is
    # at or over its limit. This will be used to generate the new status. If
    # none of the volumes are at or over limit, @details will be empty.
    
    my $summary = join ' - ', @details;
    
    # Generate output if the summary has changed from the prior state, or if we
    # are running in report mode or check mode. Update the state file only if we
    # are running in notify mode.
    
    if ( $summary ne $psummary || $REPORT || $CHECK )
    {
	if ( $ptime )
	{
	    my $elapsed = ComputeElapsed($curtime, $ptime);
	    log_message "$code $elapsed $label";
	}
	
	else
	{
	    log_message "$code $label";
	}
	
	output_message $_ foreach @volume;
	write_log $summary if $summary;
	
	if ( $NOTIFY )
	{
	    my $newtime = $code eq $pstatus ? $ptime : $curtime;	    
	    write_state "$code|$newtime|$summary|$label";
	}
    }
}


# CheckTest ( name, parameters )
# 
# A check of this type is used for testing purposes. The first time it is
# executed, the status will be OK. If the entry parameter 'cycle' has a positive
# value, then for that many subsequent executions the status will be ERR before
# returning to 'OK'. Subsequent executions will repeat the cycle. If the
# parameter 'cycle' does not have a positive value, the status will always be
# OK.

sub CheckTest {
    
    my ($name, $params) = @_;
    
    # Look up the parameters relevant to this entry.
    
    my $cycle = $params->{cycle} > 0 ? $params->{cycle} + 0 : 0;
    my $label = $params->{label} || $name;
    
    # Open the correct log file and read the prior state of this entry.
    
    SelectLog($name, $params);
    
    my $prior = ReadState($name, $params);
    
    my ($pstate, $pcount) = split /[|]/, $prior;
    
    # If the prior state is 'INIT', the new state will be OK.
    
    if ( $pstate eq 'INIT' )
    {
	log_message "OK $label";
	write_state "OK||$label" if $NOTIFY;
	return;
    }
    
    # If the prior state is 'OK', the new state will be 'ERR' if $cycle is
    # greater than zero.
    
    elsif ( $pstate eq 'OK' && $cycle )
    {
	log_message "ERR 1 $label";
	write_state "ERR|1|$label" if $NOTIFY;
	return;
    }
    
    # If the prior state is 'OK' and we are not cycling, generate output only if
    # we are running in report mode.
    
    elsif ( $pstate eq 'OK' )
    {
	output_message "OK $label" if $REPORT || $CHECK;
	write_log "OK $label";
	return;
    }
    
    # Otherwise, we are in the ERR part of the cycle. If the count does not
    # exceed the value of the cycle parameter, generate output only if we are
    # running in report mode.
    
    my $count = $pcount + 1;
    
    if ( $count <= $cycle )
    {
	output_message "ERR $count $label" if $REPORT || $CHECK;
	write_log "ERR $count $label";
	write_state "ERR|$count|$label" if $NOTIFY;
    }
    
    # When the count reaches the value of the cycle parameter, set the state
    # back to OK.
    
    else
    {
	log_message "OK $label";
	write_state "OK||$label" if $NOTIFY;
    }
}


# SendOutput ( )
# 
# Send all output that has been generated so far as a single message, possibly
# with multiple lines.

sub SendOutput {
    
    # Generate a subject for this message. If all of the check results are OK,
    # the subject will be either 'Notify OK', 'Report OK', or 'Check OK'.
    # Otherwise, it will contain a list of the abnormal result codes.
    
    my %conditions;
    
    foreach my $n ( @OUTPUT )
    {
	if ( $n =~ /^(\w+)/ )
	{
	    $conditions{$1} = 1 unless $1 eq 'OK';
	}
    }
    
    my $summary = %conditions ? join(', ', keys %conditions) : 'OK';
    
    my $action = $NOTIFY ? 'Notify'
	       : $REPORT ? 'Report'
	       :           'Check';
    
    # If the 'sendmail' option was given and the 'recipients' configuration
    # setting was set, send any notifications or reports directly via sendmail.
    # But if we are running in test mode, inform the user of the recipient list
    # and write all output to STDOUT.
    
    if ( $SENDMAIL )
    {
	my $recipients = $CONFIG->{recipients};
	
	# If we are running in report mode and recipients_report is also defined,
	# use that instead.
	
	if ( $REPORT && defined $CONFIG->{recipients_report} )
	{
	    $recipients = $CONFIG->{recipients_report};
	}
	
	# Throw an exception if no recipient list was given.
	
	die "ERROR: you must set the configuration variable 'recipients' in order to use sendmail\n"
	    unless $recipients;
	
	# If the recipient list is '$ENV{xxx}', then get the recipient from the
	# environment variable xxx or else throw an exception.
	
	if ( $recipients =~ / ^ \$ ENV \{ (\w+) \} /x )
	{
	    $recipients = $ENV{$1} or
		die "ERROR: you must set the environment variable '$1' in order to use recipients\n";
	}
	
	elsif ( $recipients =~ /^\$/ )
	{
	    die "ERROR: invalid value for 'recipients' in $CONFIG_FILE\n";
	}
	
	# If we are running in test mode, inform the user of where the output
	# would go and write it directly to STDOUT.
	
	if ( $TEST )
	{
	    say STDERR "Output would be sent via sendmail\nTo: $recipients";
	
	    if ( @OUTPUT )
	    {
		say STDOUT "$action $summary";
		say STDOUT $_ foreach @OUTPUT;
	    }
	    
	    else
	    {
		say STDERR "No output";
	    }
	}
	
	# Otherwise, open a pipe to sendmail and write the output to it.
	
	else
	{
	    open(my $sendmail, '|-', "sendmail $recipients") or 
		die "ERROR: could not run sendmail: $!\n";
	    
	    say $sendmail "From: $CONFIG->{from}" if $CONFIG->{from};
	    say $sendmail "Subject: $action $summary";
	    say $sendmail "";
	    
	    say $sendmail $_ foreach @OUTPUT;
	    
	    close $sendmail;
	}
    }
    
    # Otherwise, write the subject (summary) line followed by all output to
    # STDOUT.
    
    else
    {
	say STDOUT "$action $summary";
	say STDOUT $_ foreach @OUTPUT;
    }
}


# ComputeElapsed ( time, prevtime )
# 
# Return a string giving the difference between the first argument and the
# second in seconds (s) if less than 60, or in minutes (m) if less than 3600,
# in hours (h) if less than 86400, or in days. Any time that is 5 minutes or
# less before the start of an hour or day is rounded up.

sub ComputeElapsed {
    
    my ($time, $ptime) = @_;
    
    return '?' unless $time > 0 && $ptime > 0 && $time >= $ptime;
    
    my $diff = $time - $ptime;
    
    if ( $diff < 60 )
    {
	return "${diff}s";
    }
    
    elsif ( $diff < 3300 )
    {
	my $min = int($diff/60);
	return "${min}m";
    }
    
    elsif ( $diff < 86100 )
    {
	my $hrs = int(($diff+300)/3600);
	return "${hrs}h";
    }
    
    else
    {
	my $days = int(($diff+300)/86400);
	return "${days}d";
    }
}


# ReadState ( name, parameters )
# 
# Read the state file for the specified entry, and return its contents.

sub ReadState {
    
    my ($name, $params) = @_;
    
    # If no state file is given, it defaults to nnn_state.txt, where nnn is the
    # name of the entry being checked.
    
    my $filename = $params->{state_file} || "${name}_state.txt";
    
    # Make sure that each entry has a different state file.
    
    if ( $state_uniq{$filename} && $state_uniq{$filename} ne $name )
    {
	die "ERROR: '$state_uniq{$filename}' and '$name' have the same state file '$filename'\n";
    }
    
    $state_uniq{$filename} = $name;
    
    # If 'state_dir' is specified in the configuration file, then state files
    # are located in that directory. Otherwise, they are located in the log
    # directory.
    
    my $dir = $STATE_DIR || $LOG_DIR;
    
    $state_file = resolve_name($filename, $dir);
    
    my ($state_fh, $state);
    
    # If we are running in 'check' mode, read the state file if it exists and is
    # readable. Otherwise, return 'INIT'.
    
    if ( $CHECK )
    {
	if ( open $state_fh, '<', $state_file )
	{
	    $state = <$state_fh>;
	    chomp $state;
	    close $state_fh;
	}
	
	return ($state || 'INIT');
    }
    
    # Otherwise, create the state file if it does not exist. The initial state
    # will be 'INIT'.
    
    unless ( -e $state_file )
    {
	open($state_fh, ">", $state_file) 
	    or die "ERROR: cannot create $state_file: $!\n";
	
	say $state_fh "INIT";
	close($state_fh);
    }
    
    # Read and return the contents of the state file. Throw an exception if the
    # file is not readable or not writable and we are running in notify mode.
    
    -w $state_file or ! $NOTIFY
	or die "ERROR: cannot write $state_file: $!\n";
    
    open($state_fh, "<", $state_file) 
	or die "ERROR: cannot read $state_file: $!\n";
    
    $state = <$state_fh>;
    close $state_fh;
    chomp $state;
    
    return ($state || 'INIT');
}


# write_state ( new_state )
# 
# If we are running in notify mode, Write the specified contents to
# the file $state_file. If we are in report or check mode, do nothing.

sub write_state {
    
    my ($new_state) = @_;
    
    return unless $NOTIFY;
    
    if ( $TEST )
    {
	say STDERR "Would write state: $new_state";
	return;
    }
    
    open(my $state_fh, ">", $state_file)
	or die "ERROR: cannot write $state_file: $!\n";
    
    say $state_fh $new_state;
    
    close $state_fh
	or die "ERROR: could not write $state_file: $!\n";
}


# SelectLog ( name, parameters )
# 
# Select the proper log file for the specified entry. If that file is already
# open, then leave it. Otherwise, close the open log file (if any) and open this
# one. But do not open any log file if we are running in either check mode or
# test mode.

sub SelectLog {
    
    my ($name, $params) = @_;
    
    return if $CHECK || $TEST;
    
    my $filename = $params->{log_file} || $DEFAULT_LOG;
    
    my $this_log = resolve_name($filename, $LOG_DIR);
    
    # If this log is already open, we are done. Otherwise, close the currently
    # open log file if any and open the new one.
    
    unless ( $log_file eq $this_log )
    {
	close $log_fh if $log_fh;
	
	$log_file = $this_log;
	
	open $log_fh, '>>', $log_file
	    or die "ERROR: could not write to $log_file: $!\n";
    }
}


# output_message ( message )
# 
# Add the specified line to the output of this command.

sub output_message {
    
    my ($message) = @_;
    
    push @OUTPUT, $message;
}


# log_message ( message )
# 
# Add the specified line to the output of this command, and also write it to the
# current log file. If we are running in check mode or test mode, $log_fh will
# be undefined.

sub log_message {
    
    my ($message) = @_;
    
    push @OUTPUT, $message;
    say $log_fh "[$timestamp] $REPORT$message" if $log_fh;
}


# write_log ( message )
# 
# Write the specified line to the current log file, but don't add it to the
# output. If we are running in check mode or test mode, $log_fh will
# be undefined.

sub write_log {
    
    my ($message) = @_;
    
    say $log_fh "[$timestamp] $REPORT$message" if $log_fh;    
}


# resolve_name ( name, directory )
# 
# If the specified name is an absolute path or starts with ./ or ../, then
# return it unchanged. Otherwise, return the name relative to the specified
# directory.

sub resolve_name {
    
    my ($filename, $dir) = @_;
    
    if ( $filename =~ qr{ ^[/] | ^ [.][/] | & [.][.][/] }xs )
    {
	return $filename;
    }
    
    else
    {
	return "$dir/$filename";
    }
}



# help_message ( )
# 
# Print out a help message and exit.

sub help_message {
    
    my $command = 'webcheck';
    
    if ( $0 =~ qr{ ([^/]+) $ }x )
    {
	$command = $1;
    }
    
    my $message = <<END_HELP;

Name:

  webcheck - check the health of local or remote services

Usage:

  $command [options] [arguments]

  This program is intended to be run as a cron job, in order to notify responsible
  personnel when a server is down or is having problems. If arguments are provided, they
  cause the corresponding status checks from the configuration file to be performed. With
  no arguments, all configured status checks are performed.

Options:

    --file, -f      Use the specified configuration file. The default is ./webcheck.yml.

    --notify, -n    Run in 'notify' mode. Log all status check results, and save the status
                    of each entry in its state file. Generate output for each entry whose
                    status has changed, or when a followup notification is indicated.

    --report, -r    Run in 'report' mode. Log all status check results, and generate output
                    for each entry including those whose status is unchanged. Do not alter
                    the state files.

    --sendmail, -s  Direct all output to sendmail instead of stdout. The recipient list
                    is given by the configuration setting 'recipients' or 'recipients_report'.

    --test, -t      Write all output to stdout, ignoring 'recipients' or other directives.
                    Do not alter the state files. Write extra messages to STDERR that
                    indicate where output would otherwise go and what state would
                    otherwise be saved.

    --help, -h      Print this message.

  Single-letter options may be bundled.

Description:

  The status checks to be performed are specified by entries in the configuration file.
  The format of this file is given below.

  The default operation mode is 'check'. In this mode, the result of each status check is
  written to stdout. No log entries are written, and no state is saved. This mode can be
  used at any time to check the status of the configured services.

  In 'notify' mode, each status check result is appended to the log file and the status of
  each entry is saved to its state file. A notification message is generated when any of
  the statuses change, or when a followup notification is indicated. This program is
  intended to be run in notify mode as a cron job every 10 minutes, or as frequently as
  necessary for prompt notification of outages. The 'sendmail' option can be used to send
  these notifications via the sendmail program. This can be used with email-to-sms
  addresses to notify responsible personnel on their phones when a service is down, and/or
  to regular e-mail addresses. Alternatively, the cron variable MAILTO can be used for the
  same purpose albeit with less flexibility.

  In 'report' mode, output is generated for each status check result even if the status is
  unchanged. The state files are not updated, but all results are written to the log file.
  This program can be run in report mode periodically, perhaps once every few days, to
  provide output on a regular basis during times when no outages are detected for long
  periods. Otherwise, if something were to prevent this program from running, i.e. an
  unexpected change to the crontab file, the people who are supposed to be notified would
  not have any easy way to find out. But if the report output does not appear as expected,
  that would mean something is wrong.

  The 'test' flag can be used to check the destination for notification and report output,
  without actually sending any output and without changing the state files.

  The motivation for the state files, and for this program in general, is to
  provide for quick notification when the status of a service changes, without
  flooding the responder with notifications if an abnormal condition persists for
  hours. It is recommended to run this program every 10 minutes, or as often as
  necessary for prompt notification of problems. The 'followup' setting can be
  used to provide additional notifications on a specified pattern when an abnormal
  condition persists. For example, "1 24 60" will send a followup notification
  at 10 minutes, 4 hours, and 10 hours if an abnormal condition persists that long.

Configuration file:

  The configuration file must be in YAML format. The status check entries must be listed
  under the top level key 'checks'. The following top level keys are allowed, with the
  values interpreted as follows:

    log_file            The name of the log file, defaults to 'webcheck.log'.

    log_dir             The directory in which the log file is located, defaults to '.'

    state_dir           The directory in which the state files are located,
                        defaults to the value of log_dir.

    recipients          When the 'sendmail' option is specified on the command line,
		        send any generated output to the specified e-mail address(es)
		        directly using sendmail. Multiple addresses should be separated by
		        commas. If the value has the form '\$ENV{xxx}', the address list
		        is read from the environment variable xxx.

    recipients_report   Specifies an alternate email recipient list for report mode.

    from                Sets the 'From' header when used along with 'recipients'. The
		        value can be any valid e-mail address.

    url_command         The command to be used for checking remote services.
		        It should contain the string '%%', which will be
		        substituted with the url for each entry. The default
		        is "curl --head --silent '%%'".

    url_followup        The value must be a list of numbers. For example, if the value is
		        '1 6', followup notifications will be sent on the 2nd and 7th
		        times that an abnormal condition is detected if it persists that
		        long. If the notification interval is 10 minutes, this would cause
		        followup notifications to be sent at 10 minutes and 1 hour.

    checks              All status check entries must occur as keys under this.
		        The name of each entry is its key.

  Four types of entries are allowed. Any values specified in an entry override
  the corresponding top level values for that entry only.

  Group

    An entry with a string value represents a group of other entries. The
    value must be a list of entry names separated by spaces.

  Remote service check

    An entry of this type must include the key 'url' or 'url_command'. The specified
    command is used to fetch the specified URL, and the response is checked for the
    standard http response. A response code of 200 is considered normal, anything else is
    abnormal. The following keys are accepted:

    url               The url to be checked

    url_command       A command to be executed for this entry only

    url_followup      A followup pattern for this entry only

    label             A label string used for generating output, defaults to the
		      entry name.

    log_file          Log this entry to the specified file instead of to the main one.

    state_file        Save the state to the specified file. Default is nnn_state.txt,
                      where nnn is the name of the entry.

  Disk space check

    An entry of this type must include the key 'limit'. The command to be run
    defaults to 'df', and the output is scanned for volumes whose use% meets or
    exceeds the specified threshold. The following keys are accepted:

    limit             The threshold for notification of use% (mandatory)

    limit_/var        The threshold for notification of a particular volume,
		      in this case /var.

    df_command        A command to be executed, defaults to 'df'.

    ignore            A regexp used for filtering the command result. All lines that
                      match it will be ignored. These would typically include temporary
                      file systems, snaps, etc.

    label             A label string used for generating output, defaults
		      to the entry name.

    log_file          Log this entry to the specified file instead of to the main
		      one.

    state_file        Save the state to the specified file. Default is
		      <entry name>_state.txt.

  Test entry

    An entry of this type must include the key 'cycle'.

    cycle             If the value is greater than zero, the result will cycle
		      from 'OK' to 'ERR', and will repeat for that number of
		      executions before returning to 'OK'. If the value is zero,
		      the result will be 'OK' on every execution. (mandatory)

    label             A label string used for generating output, defaults
		      to the entry name.

    log_file          Log this entry to the specified file instead of to the main
		      one.

    state_file        Save the state to the specified file. Default is
		      <entry name>_state.txt.

END_HELP
    
    print $message;
}


